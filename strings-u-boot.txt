NP !)
	L85)
h@	x
07{ 
07{!
07{"
07{#
07{$
07{!
07{"
07{#
07{$
07{!
07{"
07{#
07{$
07{!
07{"
07{#
07{$
	NB1)
N.P@
N2P@
N.P@
N2P@
x4B0
&|Bz
x4B0
&|Bz
x4B0
&|Bz
x4B0
&|Bz
:|B 
@ -$
@ -$
|Q8CR 
-|b1
 (-6
 -0B
0-p@(,
b(-$
D(/$
x4B0
x4B0
x4B0
20!~D
0!~$
'9-h
'9-h
 -&%
 -&%
 -&%
 -&%
 -&%
 -&%
x4B0
4BB@
4cB@
D4pB@'
H-|J
H-eE
`H-1B
`H-eD
`H-1"
l,4B
2BUU4
8$P*(
4cB@<
(-4G
'9*(
%(-<
f(u04
'9*(
e,4B
@8-4F
@8-4F
x4B0
'9*(
x4B0
b<@#
a,4B
$P*(
$P*(
$P*(
$P*(
$P*(
0-4B
$P*(
0-4B
$Q*(
0-4B
$P*(
$P*(
$P*(
-86R
	61`
'9*(
H-&R
 -4c
 !0r
@0-4b
x4B0
x4B0
` -$
@ -|
(.c	
 H-'9p
X-e~
g4Bi
	|PJG<
x4B0
x4B0
x4B0
` -$
(.c	
 H-'9p
X-e~
g4Bi
x4B0
|C)G
x4B0
x4B0
x4B0
x'9p
|QbG
	|QJG
.|C!
n|C)G
x4B0
x4B0
x4B0
@ -$
@ -|
@ -$
x4B0
@ -|
x4B0
1|PJG
.|C!
n|C)G
x4B0
x4B0
x4B0
 (-&
@(-&
(!pb0
`(-&
$|UB
JG4b
x4B0
	80B
	|TR
+|TJG
	x0B
x4B0
|pIG
	|P 
	|PIG
	|Pr
4BB@$vp
-pe(
!qqH
r%(+
@(-q
r)H+
+H!pC
!}DAG
!}$bG
@!|d
`(-$
#|Q9
3|D%
#|B&
` -<
|rrG|
X|LZ
P|Cb
d81"
@X-'9p
(-'9p
x4B0
x4B0
@ -~
x4B0
x4B0
x4B0
x4B0
x4c0
*pb 
(/|b
 -&"
@ -<
C0%|
-'9+
;|PI
x4B0
@@-$
0-|P
x4B0
r|K8
r|G8
(-$B
@ -'9
@ -'9
@ -'9
%pe:2
pP:2
  -$P
  -$
  -'9
  -$R
  -$
-pP:2
0-$P
l,B11P@
H-%B
0!%)
0!%)
$ !$
@ -~c
0-$P
0-'9
0-'9
0-$P
  -'9
(-'9
(-'9
 -$T
  -$R
  -$
0!&1
` -$
@ -&
  -$
@ -$
@ -$
@ -&
@ -$
 -&1
@ -$
  -$
` -$
` -$
` -$
` -$
  -$
8$B(
p$B1
$B2T
$B$H
` -$
@0-$
0$B2T
` -$
` -*B
0-&s
  -$
`0-'9
 -P@
 -'9
  -'9
@ -$
0-&s
d !$
  -$
@ -$
@ -$
  -'9"p
'9"p
@ -$
`0-'9"p
@ -$
`0-'9*
@ -$
` -$
` -$
` -$
` -$
` -2%
` -$
` -$
` -$
` -$
` -$
` -$
` -$
j0&$
bX&0
 %}B
@!&1
<'9A
 !PI
@ -$
 8-'9D
`@-'9D
@ -$
$'9:
@ -$P> 
4$Y:
`(-'9C
 '9C
0-'9D
0-'9D
@ -$QM
 -,B
-$WU
 (-'
@(-$
1$R+
D !(
$H+p
$B-'
$B-?
$B-W
$B-w
$B./
@#2#
 (-0
`8-$
-'9kx
 8-$
#$Q.p
`(-$
0-P@
@(-&
$c/ 
$c/X
$Wkx
&D0p
&D0p
	$E1?
$E1_
$E1w
@@-$
$c3`
$c48
4@0B
@#2#
 (-0
`8-$
-$D4
 -$C
4BLF
P$V9
$rc 
C !$
:$T9
%(!$
-pb(
*$T9
 rC 
$C; 
 (-'
@ -~%
`0-'
 -$B
-$DC
 -$CC
-$EC
-$EDp
@0-$B
-$EC
-$EDp
 -,C
4&EJ
@0-4
@ -$
-$DL
 -$C2
$PMP
 @-P@
$SMp
  -&
-$^M
 -R`
$UNH
$PN@
@-$c
@8-'9
@-$c
@8-'9
@ -$
	|PY
	|Pz
` -$
  -'9
  -$
  -0
  -0
  -0
  -$
  -$
  -0
  -0
  -$
f0%$
  -$
  -'9
@8-0C
 -4BF
  -$
  -'9
  -$
  -$
  -0
  -0
  -0
  -$
;dD'
  -'9
  -7
  -$R
  -'9
  -$
0-rf
  -0
  -0
  -0
  -$
  -$
  -0
  -0
  -$
  -$
  -0
  -$
4RK@
  -'9
  -$
` -4
` -$
` -$R
` -$
@-&%
 -PG
i0+$c
 -PG
i0+$c
 -PG
i0+$c
` -$
` -$
` -'9
`(-$
 -'9
-$ET
(-$CT
(-$CT
$CU8
-$ET
@(-*"
$CU8
-$E4
(-$C
@ -$R
@8-(B
C0!|
-~B	
` -$
 0-$
 0-$
%pc:2
$4Bh
@GH'
$ -PR
@@-$
4BUU
4BUU
U4BUU
84BUU
UU4BUU
84BUU
U4cUU
84cUU
 -6c
$ -4
 0-$
[P0P
@ -(B
$ !$
@ -$
_(rS0
(-P@
$F_x$
$R`@
@ -$
@-$c
@8-'9
@-$c
@8-'9
 (-$
$D`8VB
` -&
-$DC
-$Dn
 -$Co
 -$Co
 -$Co
 -$Co
 -$Cq
 -$Cq
 -$Cr
 -$Cr
 -$CC
-$Dn
 -$Cn
 -$Ctx
 -$Ct
 -$Ct
 -$Cn
 -$Cn
 -$Cn
 -$Cq
 -$Cn
 -$Cu
 -$CvX
 -$Cw(
 -$Cwp
-$DL
 -$C2
@ -~%
 $V}
-$D~@
 -$C~p
 -$C~
 -$C
 -$C~
 -$C4
 -$C~
 -$C~
 -$C~
 -$C~
 -$C~
 -$C~
 -$C
 -$C~
@ -$c
 -$B~
8-'9
 -$C~
 -$C
 -$C4
8-'9
 -$C
 -$C
 -$C
 -$C~
  -|E
 -$C~
 -$C~
@ -$c
 -$C~
8-'9
@ -&S
@ -$
 $W#h
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
 -$C
$T#h
 -$C
-$P#h
 -$C
 -$C
 -$C
 -$C
 -$C
  -T@
@ -T@
 (-'9#h
`(-&
@ -&1
`$C(
 -$B
$BEX
$BEX
$q[0
-%)x
!$cs
!$csl
@(-$B
0'9M8
$RM8
 (-'9M8
$cp8
$coH
 -4B
$ #$
H#)"
 !%	
S #(
 !$W
5 #,
d(!$d
$c\l
$c\8
` -T@
!$BEX
@$ci
,$cV
`0-V@
C !r
!$cQ8
LI4BST
C &-
&pB8
, T`
(%rB:2
 -0S
"H$$
`-1/
` -&
`H-$
@-'9z@
H-&Q
 '9z@
 '9z@
!$B@d
&|cz
2|B$
@@-$
<4B	8
<4B	0
<4B	(
<4B	 
<4B	
	pD 
@$H'
	pD 
2>4B
@dc'
"<4c
 -4c
(-$h
b -$
*>4B
b0-$
  -*
04B 
 -'9
 -'9
 -'9
 !'9
 -'9
 -'9
 -'9
 -'9
@ -$
(-4c
(-4c
|B)C$
 -'9
04c!
-4B!
 -$B
04c!
04c!
-4B!
-4B!
04B!
(-|P
&|Px
@-%J
D !,
 %0B
pC:22C
pC:2
%|bY
(H%$
0-$D
 -$	
@ -4
@(-$B
^pb0
8-'9
pD((
 -'9
JpC:2
DpC:2
 @-'9
pD((
@ -'9
`(-'9
 %0B
f %$
pC:2
@H-$B
0-$R
0-$c
0-$c
@0-$
"@#r
(-R@
8-PW
@8-&$
(!'9
H-$c
0-'9
8-0B
L(!0
LH!qD
MP!p
(#$B
(#$B
CVMX_BOARD_TYPE_SIM
CVMX_BOARD_TYPE_NULL
CVMX_BOARD_TYPE_EBT3000
CVMX_BOARD_TYPE_KODAMA
CVMX_BOARD_TYPE_NIAGARA
CVMX_BOARD_TYPE_NAC38
CVMX_BOARD_TYPE_THUNDER
CVMX_BOARD_TYPE_TRANTOR
CVMX_BOARD_TYPE_EBH3000
CVMX_BOARD_TYPE_EBH3100
CVMX_BOARD_TYPE_HIKARI
CVMX_BOARD_TYPE_CN3010_EVB_HS5
CVMX_BOARD_TYPE_CN3005_EVB_HS5
CVMX_BOARD_TYPE_KBP
CVMX_BOARD_TYPE_CN3020_EVB_HS5
CVMX_BOARD_TYPE_EBT5800
CVMX_BOARD_TYPE_NICPRO2
CVMX_BOARD_TYPE_EBH5600
CVMX_BOARD_TYPE_EBH5601
CVMX_BOARD_TYPE_EBH5200
CVMX_BOARD_TYPE_BBGW_REF
CVMX_BOARD_TYPE_NIC_XLE_4G
CVMX_BOARD_TYPE_EBT5600
CVMX_BOARD_TYPE_EBH5201
CVMX_BOARD_TYPE_EBT5200
CVMX_BOARD_TYPE_CB5600
CVMX_BOARD_TYPE_CB5601
CVMX_BOARD_TYPE_CB5200
CVMX_BOARD_TYPE_GENERIC
CVMX_BOARD_TYPE_MAX
CVMX_BOARD_TYPE_CUST_DEFINED_MIN
CVMX_BOARD_TYPE_CUST_WSX16
CVMX_BOARD_TYPE_CUST_NS0216
CVMX_BOARD_TYPE_CUST_NB5
CVMX_BOARD_TYPE_CUST_WMR500
CVMX_BOARD_TYPE_CUST_ITB101
CVMX_BOARD_TYPE_CUST_NTE102
CVMX_BOARD_TYPE_CUST_AGS103
CVMX_BOARD_TYPE_CUST_GST104
CVMX_BOARD_TYPE_CUST_GCT105
CVMX_BOARD_TYPE_CUST_AGS106
CVMX_BOARD_TYPE_CUST_SGM107
CVMX_BOARD_TYPE_CUST_GCT108
CVMX_BOARD_TYPE_CUST_AGS109
CVMX_BOARD_TYPE_CUST_GCT110
CVMX_BOARD_TYPE_CUST_DEFINED_MAX
CVMX_BOARD_TYPE_CUST_PRIVATE_MIN
CVMX_BOARD_TYPE_CUST_N100
CVMX_BOARD_TYPE_CUST_N100W
CVMX_BOARD_TYPE_CUST_N100D
CVMX_BOARD_TYPE_CUST_N100DE
CVMX_BOARD_TYPE_CUST_N100WDE
CVMX_BOARD_TYPE_CUST_N100DF
CVMX_BOARD_TYPE_CUST_N100WDEF
CVMX_BOARD_TYPE_CUST_N100DEF
CVMX_BOARD_TYPE_CUST_DSR500
CVMX_BOARD_TYPE_CUST_DSR500N
CVMX_BOARD_TYPE_CUST_DSR1000
CVMX_BOARD_TYPE_CUST_DSR1000N
CVMX_BOARD_TYPE_CUST_PRIVATE_MAX
Unsupported Board
### ERROR ### Please RESET the board ###
DRAM:  
ERROR: malloc heap exhausted!
baudrate
hanging, init func: %d
Error message from before serial ready: %s
*************************************
ERROR: U-boot memory usage overlaps fixed address reserved area!
U-boot base address: 0x%08x, reserved top: 0x%08x
*************************************
N100
N100W
N100D
N100DE
N100WDE
N100DF
N100WDEF
Unknown
00:00:A0:01
000000000001
0000000000001
protect off 0x%x 0x%x
erase 0x%x 0x%x
cp.b 0x%x 0x%x 0x%x
IPD backpressure workaround verified, took %d loops
IPD backpressure workaround FAILED verfication. Adjust octeon_ipd_bp_enable() for this chip!
IPD backpressure workaround FAILED. Adjust octeon_ipd_bp_enable() for this chip!
PCIe: Aligning TLP counters (OUT_P_COUNT=%d)
PCIe: Soft reset after alignment
Clearing DRAM.....
 done
FATAL: Error initializing free memory list
__tmp_bootloader_internal
ERROR: Unable to allocate memory for heap.... (1)
octeon_reserved_mem_load_size
auto
octeon_reserved_mem_load_base
__tmp_load
ERROR: Unable to allocate bootloader reserved memory (addr: 0x%x, size: 0x%x).
0x%x
loadaddr
WARNING: No reserved memory for image loading.
octeon_reserved_mem_linux_size
octeon_reserved_mem_linux_base
__tmp_reserved_linux
ERROR: Unable to allocate linux reserved memory (addr: 0x%x, size: 0x%x).
Flash: 
Flash boot bus region not enabled, skipping NOR flash config
NAND:  
0x%04x
coremask_override
Warning: No chip capability tuple found in eeprom, coremask_override may be set incorrectly
numcores
ethaddr
ipaddr
pci_console_active
Using PCI console, serial port disabled.
stdin
stdout
stderr
PCI CONS
serial
%s board revision major:%d, minor:%d, serial #: %s
OCTEON %s revision: %d, Core clock: %d MHz, DDR clock: %d MHz (%d Mhz data rate)
WARNING: loadaddr not set, defaulting to %s.  Please either define a load reserved block or set the loadaddr environment variable.
env_addr
env_size
flash_base_addr
flash_size
uboot_flash_addr
uboot_flash_size
flash_unused_addr
flash_unused_size
ddr_clock_hertz
Parameter found in environment. ddr_clock_hertz = %d
ddr_ref_hertz
Parameter found in environment. ddr_ref_hertz = %d
OCTEON %s, Core clock: %d MHz, DDR clock: %d MHz (%d Mhz data rate)
WARNING:
WARNING: Measured DDR clock mismatch! expected: %d MHz, measured: %d MHz, cpu clock: %d MHz
WARNING: Using measured clock for configuration.
WARNING:
Warning: Clock descriptor tuple not found in eeprom, using defaults
WARNING: memory configured for %d mhz clock.  
If this is not the actual memory clock
poor performance and memory instability may result.  
The memory speed must be specified in the board eeprom
Warning: Board descriptor tuple not found in eeprom, using defaults
*** failed ***
fileaddr
filesize
WARNING: Data loaded outside of the reserved load area, memory corruption may occur.
WARNING: Please refer to the bootloader memory map documentation for more information.
ERROR copying memory using TLB mappings, cur_len: %d !
__tmp
autoload=n
dram_size_mbytes=%d
####################################################################################
### Warning: only %02d cores available, not running with requested number of cores ###
ERROR: Can't boot cores that don't exist! (available coremask: 0x%x)
Notice: coremask changed to 0x%x based on coremask_override of 0x%x
WARNING:
WARNING: You have changed the coremask_override and are running code on non-functional cores.
WARNING: The program may crash and/or produce unreliable results.
ERROR allocating stack for core: %d
__bootloader_env
ERROR: unable to allocate memory for argument data
icache_prefetch_disable
ERROR allocating memory for boot descriptor block
ERROR allocating memory for cvmx bootinfo block
cvmx_ptr_to_phys() passed a NULL pointer
WARNING: L2D ECC errors detected!
WARNING: L2T ECC errors detected!
WARNING: DDR ECC errors detected!
BIST FAILURE: %s, error bits: 0x%llx
BIST FAILURE: %s, error bits ((bist_val & mask) ^ expected): 0x%llx
BIST FAILURE: POW_BIST_STAT: 0x%08x
COP0_CVMMEMCTL_REG
COP0_ICACHEERR_REG
GMX0_BIST
GMX1_BIST
IPD_BIST_STATUS
KEY_BIST_REG
L2D_BST0
L2C_BST0
L2C_BST1
L2C_BST2
CIU_BIST
PKO_REG_BIST_RESULT
NPI_BIST_STATUS
PIP_BIST_STATUS
RNM_BIST_STATUS
SPX0_BIST_STAT
SPX1_BIST_STAT
TIM_REG_BIST_RESULT
TRA_BIST_STATUS
MIO_BOOT_BIST_STAT
IOB_BIST_STATUS
DFA_BST0
DFA_BST1
FPA_BIST_STATUS
ZIP_CMD_BIST_RESULT
USBNX_BIST_STATUS(0)
AGL_GMX_BIST
MIXX_BIST(0)
NPEI_BIST_STATUS
RAD_REG_BIST_RESULT
PCSX0_BIST_STATUS_REG(0)
PCSX1_BIST_STATUS_REG(1)
BIST Errors found.
'1' bits above indicate unexpected BIST status.
BIST check passed.
PCI console already setup.
pci_console_count
pci_console_size
WARNING: PCI console init FAILED
PCI console init succeeded, %d consoles, %d bytes each
Reading simulated SPD %p
Unbuffered
Registered
non-ECC
DIMM %d: DDR2 %s, %s
  %s
ddr_verbose
ddr_prompt
ERROR: DDR Reference Clock not specified.
clkr: %2lu, en: %2d, clkf: %4lu, pll_MHz: %4lu, ddr_hertz: %8lu, error: %8d
clkr: %2lu, en: %2d, clkf: %4lu, pll_MHz: %4lu, ddr_hertz: %8lu, error: %8d <==
ERROR: Can not compute a legal DDR clock speed configuration.
ddr_sil_mode
Parameter found in environment. ddr_sil_mode = %d
Disabled
Enabled
DDR Interface %d: %s,  Mask 0x%x
DDR Interface %d: %s, Target DCLK: %d
Enabling DCLK PLL
DDR Interface %d: %s
Performing LMC1 DCLK Offsetting Sequence
Performing DRESET Initialization Sequence
BIST ERROR: 0x%llx
CSRD2E = 0x%x
CSRE2D = 0x%x
MWF    = 0x%x
MWD    = 0x%x
MWC    = 0x%x
MRF    = 0x%x
MRD    = 0x%x
Performing LMCX Initialization Sequence
Measured DDR clock %d
DDR clock misconfigured. Resetting...
Please enter value for %s DDR param(enter for default):
No value entered, using default value for parameter %s
Using value %s for parameter %s
Initializing DDR interface %d, DDR Clock %d, DDR Reference Clock %d
ERROR: No dimms specified in the dimm_config_table.
ERROR: Install DIMMs in pairs for 128-bit interface
ddr_safe
Parameter found in environment. ddr_safe = %d
ERROR: DIMM 0 not detected.
ddr_narrow
Parameter found in environment: ddr_narrow, forcing narrow ddr interface
Unsupported number of Col Bits: %d
Unsupported number of Row Bits: %d
ERROR: Unsupported Octeon model: 0x%x
NOTICE: Memory size reduced by half on 2 rank memory configs.
row bits: %d, col bits: %d, banks: %d, ranks: %d, dram width: %d, size: %d MB
+ECC
DRAM Interface width: %d bits %s
CAS Latency was not specified by SPD: %#04x
CL%d Minimum Clock Rate                        : %6d ps
WARNING!!!!!!: DDR Clock Rate (tCLK) exceeds DIMM specifications!!!!!!!!
Unsupported refresh rate: %#04x
DDR Clock Rate (tCLK)                         : %6d ps
CAS Latency                                   : %6d
Refresh Rate (tREFI)                          : %6d ns
Minimum Row Precharge Time (tRP)              : %6d ps
Minimum Row Active to Row Active delay (tRRD) : %6d ps
Minimum RAS to CAS delay (tRCD)               : %6d ps
Minimum Active to Precharge Time (tRAS)       : %6d ps
Write Recovery Time (tWR)                     : %6d ps
Internal write to read command delay (tWTR)   : %6d ps
Device Min Auto-refresh Active/Command (tRFC) : %6d ps
Unsupported number of banks %d. Must be 4 or 8.
Unsupported number of ranks: %d
Unsupported SDRAM Width, %d.  Must be 8 or 16.
ddr_board_delay
Overriding internal board delay (%d ps).
Parameter found in environment. ddr_board_delay = %d ps
Board delay                                   : %6d ps
Error!!!  Board delay was not specified!!!
ddr_tskw
Parameter found in environment. ddr_tskw = %d
ddr_silo_hc
Parameter found in environment. ddr_silo_hc = %d
ddr_silo_qc
Parameter found in environment. ddr_silo_qc = %d
ddr_dic
Parameter found in environment. ddr_dic = %d
ddr_qs_dic
Parameter found in environment. ddr_qs_dic = %d
ddr_odt_ena
Parameter found in environment. ddr_odt_ena = %d
ddr_odt_mask
Parameter found in environment. ddr_odt_mask = 0x%x
ddr_odt_mask1
Parameter found in environment. ddr_odt_mask1 = 0x%x
ddr_rodt_ctl
Parameter found in environment. ddr_rodt_ctl = 0x%x
ddr_2t
Parameter found in environment. ddr_2t = %d
ddr_burst8
Parameter found in environment. ddr_burst8 = %d
ddr_delay_clk
Parameter found in environment. ddr_delay_clk = %d
ddr_delay_cmd
Parameter found in environment. ddr_delay_cmd = %d
ddr_delay_dq
Parameter found in environment. ddr_delay_dq = %d
delay_clk                                     : %6d
delay_cmd                                     : %6d
delay_dq                                      : %6d
sil_mode                                      : %6d
DDR Fixed Reference Clock Hertz               : %8d
clkf                                          : %6d
clkr                                          : %6d
EN2                                           : %6d
EN4                                           : %6d
EN6                                           : %6d
EN8                                           : %6d
EN12                                          : %6d
EN16                                          : %6d
LMC PLL Frequency                             : %6d MHz
Calculated DClk Frequency                     : %8d Hz
DDR PMOS dat                                  : %6d
DDR NMOS dat                                  : %6d
bunk_enable                                   : %6d
burst8                                        : %6d
ddr2t                                         : %6d
tskw                                          : %6d
silo_hc                                       : %6d
silo_qc                                       : %6d
sil_lat                                       : %6d
r2r_slot                                      : %6d
odt_ena                                       : %6d
qs_dic                                        : %6d
dic                                           : %6d
ctl_odt_mask                                  : %08x
ctl_odt_mask1                                 : %08x
ctl_rodt_ctl                                  : %08x
ddr_rodt_ena
Parameter found in environment. ddr_rodt_ena = %d
RODT enable                                   : %6d
RODT pctl                                     : %6d
RODT nctl                                     : %6d
DDR PMOS control                              : %6d
DDR NMOS control                              : %6d
ddr_read_level
Parameter found in environment. ddr_read_level = %d
Rank(%d) Status / Deskew Bytes 8:0      %#6x : %2d %2d %2d %2d %2d %2d %2d %2d %2d
Rank(%d) Read Level Debug Test Results 8:0     : %04x %04x %04x %04x %04x %04x %04x %04x %04x
lmc_nxm                                       :     %02x
disable_l2_index_aliasing
L2 index aliasing disabled.
limit_l2_ways
Limiting L2 to %d ways
Invalid limit_l2_ways value: %d, must be between 1 and %d
limit_dram_mbytes
Limiting DRAM size to %d MBytes based on limit_dram_mbytes env. variable
ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p
List of currently allocated named bootmem blocks:
Name: %s, address: 0x%08qx, size: 0x%08qx, index: %d
No named bootmem blocks exist.
Printing bootmem block list, descriptor: %p,  head is 0x%llx
Descriptor version: %d.%d
Warning: Bootmem descriptor version is newer than expected
mem list is empty!
Block address: 0x%08qx, size: 0x%08qx, next: 0x%08qx
Internal bootmem_alloc() error: ent: 0x%llx, next: 0x%llx
ERROR: no memory for cvmx_bootmem descriptor provided
ERROR: requested memory size too large, truncating to maximum size
FATAL ERROR: unable to allocate memory for bootmem descriptor!
cvmx_phys_to_ptr() passed a zero address
%d.%d
%d%c
%s%c
CN%s%s-%s pass %s
Unsupported OCTEON Model in %s
ERROR: cvmx_get_l2c_tag association out of range
ERROR: cvmx_get_l2c_tag index out of range (arg: %d, max: %d)
CFI conformant
CFI: Unknown command set 0x%x
%d erase regions found, only %d used
ERROR: too many flash sectors
## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB
missing or unknown FLASH type
%s FLASH (%d x %d)
  Size: %ld kB in %d Sectors
  Size: %ld MB in %d Sectors
Intel Prog Regions
Intel Standard
Intel Extended
AMD Standard
AMD Extended
Unknown (%d)
 command set, Manufacturer ID: 0x%02X, Device ID: 0x%02X
%04X
  Erase timeout: %ld ms, write timeout: %ld ms
  Buffer write timeout: %ld ms, buffer size: %d bytes
  Sector Start Addresses:
  %08lX   %s 
Flash %s timeout at address %lx data %lx
Flash %s error at address %lx
Command Sequence Error.
Block Erase Error.
Locking Error
Block locked.
Vpp Low Error.
write
Can't erase unknown flash type - aborted
- no sectors to erase
- Warning: %d protected sectors will not be erased!
erase
%u MiB
No oob scheme defined for oobsize %d
No ECC functions supplied, Hardware ECC not possible
U-Boot BUG at %s:%d!
nand_base.c
%d byte HW ECC not possible on %d byte page size, fallback to SW ECC
NAND_ECC_NONE selected by board driver. This is not recommended !!
Invalid NAND_ECC_MODE %d
Invalid ecc parameters
nand_resume() called for a chip which is not in suspended state
%s: second ID read did not match %02x,%02x against %02x,%02x
NAND device: Manufacturer ID: 0x%02x, Chip ID: 0x%02x (%s %s)
NAND bus width %d instead %d bit
No NAND device found!!!
%d NAND chips detected
nand_write: Attempt to write not page aligned data
nand_do_write_ops: Device is write protected
nand_erase: attempt to erase a bad block at page 0x%08x
Timeout!
NAND 16MiB 1,8V 8-bit
NAND 16MiB 3,3V 8-bit
NAND 16MiB 1,8V 16-bit
NAND 16MiB 3,3V 16-bit
NAND 32MiB 1,8V 8-bit
NAND 32MiB 3,3V 8-bit
NAND 32MiB 1,8V 16-bit
NAND 32MiB 3,3V 16-bit
NAND 64MiB 1,8V 8-bit
NAND 64MiB 3,3V 8-bit
NAND 64MiB 1,8V 16-bit
NAND 64MiB 3,3V 16-bit
NAND 128MiB 1,8V 8-bit
NAND 128MiB 3,3V 8-bit
NAND 128MiB 1,8V 16-bit
NAND 128MiB 3,3V 16-bit
NAND 256MiB 3,3V 8-bit
NAND 256MiB 1,8V 8-bit
NAND 256MiB 1,8V 16-bit
NAND 256MiB 3,3V 16-bit
NAND 512MiB 1,8V 8-bit
NAND 512MiB 3,3V 8-bit
NAND 512MiB 1,8V 16-bit
NAND 512MiB 3,3V 16-bit
NAND 1GiB 1,8V 8-bit
NAND 1GiB 3,3V 8-bit
NAND 1GiB 1,8V 16-bit
NAND 1GiB 3,3V 16-bit
NAND 2GiB 1,8V 8-bit
NAND 2GiB 3,3V 8-bit
NAND 2GiB 1,8V 16-bit
NAND 2GiB 3,3V 16-bit
AND 128MiB 3,3V 8-bit
Toshiba
Samsung
Fujitsu
National
Renesas
ST Micro
Hynix
Micron
create_bbt(): chipnr (%d) > available chips (%d)
Bad block table not found for chip %d
Bad block table found at page %d, version 0x%02X
nand_bbt: Error reading bad block table
nand_bbt: ECC error while reading bad block table
nand_read_bbt: Reserved block at 0x%08x
nand_read_bbt: Bad block at 0x%08x
No space left to write bad block table
nand_bbt: Error reading block for writing the bad block table
nand_bbt: ECC error while reading block for writing bad block table
Bad block table written to 0x%08x, version 0x%02X
nand_bbt: Error while writing bad block table %d
nand_update_bbt: Out of memory
nand_scan_bbt: Out of memory
nand_bbt: Can't scan flash and build the RAM-based BBT
nand_bbt: Out of memory
Bad block table at page %d, version 0x%02X
## Command too long!
setenv
** Too many args (max. %d) **
Unknown command '%s' - try 'help'
Usage:
## Error: "%s" not defined
bootdelay
bootcmd
N100 Failsafe bootloader# 
<INTERRUPT>
verify
Bad magic number
Bad header crc
Bad data crc
Bad image type
Empty Script
## Executing script at %08lx
autoscr
autoscr - run script from memory
[addr] - run script starting at addr - A valid autoscr header must be present
## Starting application at 0x%08lX ...
## Application terminated, rc = 0x%lX
go      - start application at address 'addr'
addr [arg ...]
    - start application at address 'addr'
      passing 'arg' as arguments
reset
reset   - Perform RESET of the CPU
List of available devices:
%-8s %08x %c%c%c 
coninfo
coninfo - print console devices and informations
Reset RTC...
## Bad date format
unknown 
Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d
Tues
Wednes
Thurs
Satur
date
date    - get/set/reset date & time
[MMDDhhmm[[CC]YY][.ss]]
date reset
  - without arguments: print date & time
  - with numeric argument: set the system date & time
  - with 'reset' argument: reset the RTC
Unknown customer tuple type
Unknown tuple type
EEPROM_CLOCK_DESC_TYPE
EEPROM_NULL_TYPE
EEPROM_BOARD_DESC_TYPE
EEPROM_CHIP_CAPABILITY_TYPE
EEPROM_MAC_ADDR_TYPE
EEPROM_VOLT_MULT_TYPE
EEPROM_RLDRAM_DESC_TYPE
EEPROM_DDR_CLOCK_DESC_TYPE
EEPROM_MAX_TYPE
EEPROM_CUSTOMER_RESERVED_START
EEPROM_CUSTOMER_RESERVED_END
EEPROM_END_TYPE
Deleting %s (0x%x) tuple at address 0x%x, length %d
Copying tuple type %d (len 0x%x)to addr: 0x%x
Error writing tuple type %d to addr: 0x%x
Writing tuple type %d to addr: 0x%x
help
Board types: 
	%10s:	 %d
delete
Error deleting tuple (address %d (0x%x).
display
==========================================
%s (0x%x) tuple found: at addr 0x%x
type: 0x%x, len: 0x%x, csum: 0x%x, maj_ver: %d, min_ver: %d
WARNING: tuple version mismatch, display may be wrong. (compiled for version: %d)
DDR clock: %d Mhz (raw: 0x%x)
CPU ref clock: %d Mhz (raw: 0x%x)
SPI clock (deprecated): %d Mhz (raw: 0x%x)
DFA ref clock: %d Mhz (raw: 0x%x)
Board type: %s (0x%x) 
Board revision major:%d, minor:%d
CVMX_CHIP_SIM_TYPE_DEPRECATED
CVMX_CHIP_TYPE_NULL
CVMX_CHIP_TYPE_OCTEON_SAMPLE
CVMX_CHIP_TYPE_MAX
Unsupported Chip
Chip  type (deprecated): %s (0x%x)
Chip  revision (deprecated) major:%d, minor:%d
Board ser #: %s
Coremask: 0x%04x, voltage_x100: %d, cpu_freq_mhz: %d
MAC base: %02x:%02x:%02x:%02x:%02x:%02x, count: %d
Voltage: %d millivolts
CPU multiplier: %d
clock
Setting clock descriptor...
ddr: %d, cpu ref: %d, dfa ref: %d spi: %d
Using version 1 clock descriptor for ebt3000 board
board
Setting board descriptor...
Board type: %d, rev: %d.%d, serial: %s
capability
Setting chip capability descriptor...
Setting mac address descriptor...
Setting mac count to: %d
volt
Setting voltage to %d millivolts and cpu multiplier to %d
read
EEPROM @0x%lX %s: addr %08lx  off %04lx  count %ld ... 
done
eeprom
eeprom  - EEPROM sub-system
read  addr off cnt
eeprom write addr off cnt
       - read/write `cnt' bytes at EEPROM offset `off' to/from memory address 'addr'
tlv_eeprom
tlv_eeprom  - EEPROM data parsing for ebt3000 board
tlv_eeprom [display|set|delete|help]
tlv_eeprom display
       - display contents of eeprom data structures
tlv_eeprom set
       - set contents of eeprom data structures, values in hex or decimal
       set clock [ddr_clock in Mhz] [cpu_ref_clock in Mhz * 8] [dfa_ref_clock in Mhz * 8] [spi_clock in Mhz]
       set board [board type] [major rev] [minor rev]  [serial string]
       set mac    [mac base x:x:x:x:x:x] [mac addr count]
       set capability [coremask_override] [voltage * 100] [cpu core freq in Mhz]
       set volt [voltage in millivolts] [cpu multiplier]
tlv_eeprom delete [tuple addr]
       - deletes tuple at address and compacts any following tuples.
Chip types have been deprecated, and can no longer be set.
(use tlv_eeprom help for list of board types)
## No elf image at address 0x%08lx
ELF file is 32 bit
ELF file is 64 bit
ERROR: invalid elf class
## Not an Executable elf image at address 0x%08lx
Processing PHDR %d
  Loading %lx bytes at %llx
  Clearing %lx bytes at %llx
Load
Clear
%sing %s @ 0x%08qx (0x%lx bytes)
%sing %s @ 0x%08lx (%ld bytes)
## Starting application at 0x%08lx ...
## Application terminated, rc = 0x%lx
bootelf
bootelf - Boot from an ELF image in memory
 [address] - load address of ELF image.
 If address is 0, default load address is used.
usage: fatinfo <interface> <dev[:part]>
** Invalid boot device **
** Invalid boot device, use `dev[:part]' **
** Unable to use %s %d:%d for fatinfo **
usage: fatls <interface> <dev[:part]> [directory]
** Unable to use %s %d:%d for fatls **
No Fat FS detected
usage: fatload <interface> <dev[:part]> <addr> <filename> [bytes]
** Unable to use %s %d:%d for fatload **
** Unable to read "%s" from %s %d:%d **
%ld bytes read
0x%lX
filename
usage: fatloadalloc <interface> <dev[:part]> <addr> <filename> [alloc_name]
ERROR getting filesize for file: %s
Error allocating named block: name: %s, address: 0x%08x
Allocated block %s at 0x%08x, %ld bytes read
fatloadalloc
fatloadalloc - load binary file from a dos filesystem, and allocate
          a named bootmem block for file data
<interface> <dev[:part]>  <addr> <filename> [alloc_name]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from dos filesystem and allocate named bootmem block
      Sets environment variables filesize, fileaddr, filename
      If addr is 0, then load address will be allocated.
      If alloc_name is omitted, the filename will be used as the name of the block
fatload
fatload - load binary file from a dos filesystem
<interface> <dev[:part]>  <addr> <filename> [bytes]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from dos filesystem
      Sets environment variables filesize, fileaddr, filename
      If addr is 0, then file will be loaded to the default load address
fatls
fatls   - list files in a directory (default /)
<interface> <dev[:part]> [directory]
    - list files from 'dev' on 'interface' in a 'directory'
fatinfo
fatinfo - print information about filesystem
<interface> <dev[:part]>
    - print information about filesystem from 'dev' on 'interface'
Error: end address not on sector boundary
Error: end sector precedes start sector
Error: cannot span across banks when they are mapped in reverse order
%sProtected %d sectors
Error: start and/or end address not on sector boundary
%sProtect Flash Bank # %ld
Bad sector specification
%sProtect Flash Sectors %d-%d in Bank # %d
bank
Only FLASH Banks # 1 ... # %d supported
Erased %d sectors
Erase Flash Bank # %ld 
Erase Flash Sectors %d-%d in Bank # %d 
Testing nor flash from %x to %x, length= %x:
Erasing Flash...
Writing to Flash...
NOR flash test pass.
NOR flash test fail.
Bank # %ld: 
flinfo
flinfo  - print FLASH memory information
    - print information for all FLASH memory banks
flinfo N
    - print information for FLASH memory bank # N
erase   - erase FLASH memory
start end
    - erase FLASH from addr 'start' to addr 'end'
start +size    - erase FLASH from addr 'start' to addr 'start + size', rounded up to sector size
erase N:SF[-SL]
    - erase sectors SF-SL in FLASH bank # N
erase bank N
    - erase FLASH bank # N
erase all
    - erase all FLASH banks
protect
protect - enable or disable FLASH write protection
on  start end
    - protect FLASH from addr 'start' to addr 'end'
protect on  N:SF[-SL]
    - protect sectors SF-SL in FLASH bank # N
protect on  bank N
    - protect FLASH bank # N
protect on  all
    - protect all FLASH banks
protect off start end
    - make FLASH from addr 'start' to addr 'end' writable
protect off N:SF[-SL]
    - make sectors SF-SL writable in FLASH bank # N
protect off bank N
    - make FLASH bank # N writable
protect off all
    - make all FLASH banks writable
w83l786g: i2c_read failed regaddr = 0x%x
VCORE =%d.%03d V
VRAM =%d.%03d V
Vcc =%d.%03d V
Vin1-Singal core CPU voltage =%d.%03d V
Vin2-Dual core,or 700MHz =%d.%03d V
invalid gpio number
w83l786g_test regaddr = 0x%x
value = %x
%d%s
-%d%s
-0.5
CPU temperature: %s
Switch temperature: %s
Read GPIO %d = %x .
pca9535: i2c_write failed
w83l786g: i2c_write failed regaddr = 0x%x
w83l786g_gpio_1_5_output_mode_control emtry
w83l786g_gpio_1_7_output_default emtry
Invalid value.
Set GPIO %d=%d .
w83l786g_gpio_io_def emtry
w83l786g_gpio_mode_setting emtry
pca9535: i2c_read failed
./gpioexpctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
Read expanded GPIO %u : %u 
./gpioexpctrl <set> <gpio pin number> <0/1>
Write expanded GPIO %u : %u 
invalid setting vlaue
Error reading the chip.
Error writing the chip.
Valid chip addresses:
 %02X
%04x:
 %02x
    
CRC32 for %08lx ... %08lx ==> 
Error reading the chip,
%08lx:
Error reading the chip,
 %02lx
 %04lx
 %08lx
gpioexpctrl
gpioexpctrl   - control expanded gpio 
	 Control expanded GPIO. 
	 gpioexpctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
imd     - i2c memory display
chip address[.0, .1, .2] [# of objects]
    - i2c memory display
imm     - i2c memory modify (auto-incrementing)
chip address[.0, .1, .2]
    - memory modify, auto increment address
inm     - memory modify (constant address)
chip address[.0, .1, .2]
    - memory modify, read and keep address
imw     - memory write (fill)
chip address[.0, .1, .2] value [count]
    - memory write (fill)
icrc32
icrc32  - checksum calculation
chip address[.0, .1, .2] count
    - compute CRC32 checksum
iprobe
iprobe  - probe to discover valid I2C chip addresses
    -discover valid I2C chip addresses
iloop
iloop   - infinite loop on address range
chip address[.0, .1, .2] [# of objects]
    - loop, reading a set of addresses
gettemp
gettemp   - get the temparature of board
gettemp
getvoltage
getvoltage   - get the CPU voltage of board
getvoltage
ERROR: Unsupported DMA mode: %d
ERROR: Unable to register IDE device, IDE descriptor list full!
IDE read: device %d not ready
Error on write (no IRQ) dev %d blk %ld: status 0x%02x
IDE read: device %d not idle
ERROR: timeout waiting for DMA completion
Error on read (no IRQ) dev %d blk %ld: status 0x%02x
  ide %d: 
Setting DMA mode for device
 Bus %d (CF Card): 
 Bus %d (IDE)    : 
 Bus %d (SATA)   : OK
** Timeout **
not available  
Reset IDE: 
IDE device %d: 
no IDE devices available
IDE device %d: 
part
unknown device
... is now current device
IDE device %d not available
IDE read: device %d block # %qd, count %ld ... 
ERROR
%ld blocks read: %s
IDE write: device %d block # %qd, count %ld ... 
%ld blocks written: %s
ide     - IDE sub-system
reset - reset IDE controller
ide info  - show available IDE devices
ide device [dev] - show or set current device
ide part [dev] - print partition table of one or all IDE devices
ide read  addr blk# cnt
ide write addr blk# cnt - read/write `cnt' blocks starting at block `blk#'
    to/from memory address `addr'
Unknown operator '%s'
Invalid data width specifier
itest
itest	 - return true/false on integer compare
[.b, .w, .l, .s] [*]value1 <op> [*]value2
download_baudrate
## Switching baudrate to %d bps for kermit download...
## Ready for binary (kermit) download to 0x%08lX at %d bps...
## Total Size      = 0x%08x = %d Bytes
0x%X
## Binary (kermit) download aborted
## Start Addr      = 0x%08lX
## Switching to baudrate to %d bps....
loadb
loadb   - load binary file over serial line (kermit mode)
[ off ] [ baud ]
    - load binary file over serial line with offset 'off' and baudrate 'baud'
 sets environment variables filesize, load_addr
 If offset is 0, then file will be loaded to the default load address
Error freeing block: %s
Base Address64: 0x%16qx, 
Base Address: 0x%08lx
writing 0x%x to addr: 0x%llx
writing 0x%llx to addr: 0x%llx
attempting to read from addr: 0x%llx
0x%llx: 0x%x
0x%llx: 0x%llx
named_block_addr
named_block_size
Named allocation failed!
Allocated 0x%llx bytes at address: 0x%llx, name: %s
0x%llx
Looking for value other than 0x%x, addr: 0x%x
Found 0x%x at addr %p
MD5 for %08lx ... %08lx ==> %08llx%08llx
verify not supported
CRC32 for %08lx ... %08lx ==> %08lx
error : wrong pattern in 
baseAddress[offset]= %qx , offset %qx, octeon_read64(baseAddress)=%qx, pattern=%qx
baseAddress[offset]= %qx , offset %qx, octeon_read64(baseAddress)=%qx, antipattern=%qx
Testing memory ...
Testing first 128M memory :
Testing from %qx to %qx.
Data bus test error!
Data bus test passed.
Address bus test error!
Address bus test passed.
Device test error!
Device test passed.
All memory test passed.
Zero length ???
Copy to Flash... 
word at 0x%08lx (0x%08lx) != word at 0x%08lx (0x%08lx)
word
halfword at 0x%08lx (0x%04x) != halfword at 0x%08lx (0x%04x)
byte at 0x%08lx (0x%02x) != byte at 0x%08lx (0x%02x)
byte
halfword
Total of %ld %s%s were the same
 %08x
 %04x
Lower 256Mb
Middle 256Mb
Upper 15.5Gb
md      - memory display
[.b, .w, .l] address [# of objects]
    - memory display
mm      - memory modify (auto-incrementing)
[.b, .w, .l] address
    - memory modify, auto increment address
nm      - memory modify (constant address)
[.b, .w, .l] address
    - memory modify, read and keep address
mw      - memory write (fill)
[.b, .w, .l] address value [count]
    - write memory
cp      - memory copy
[.b, .w, .l] source target count
    - copy memory
cmp     - memory compare
[.b, .w, .l] addr1 addr2 count
    - compare memory
crc32
crc32   - checksum calculation
address count [addr]
    - compute CRC32 checksum [save at addr]
md5   - MD5 hash calculation
address count [addr]
    - compute MD5 [save at addr]
base
base    - print or set address offset
    - print address offset for memory commands
base off
    - set address offset for memory commands to 'off'
read64
read64    - read 64 bit word from 64 bit address
    - read 64 bit word from 64 bit address
read64 addr
    - read 64 bit word from 64 bit address
write64
write64    - write 64 bit word to 64 bit address
    - write 64 bit word to 64 bit address
write64 addr val
    - write 64 bit word to 64 bit address
namedalloc
namedalloc    - Allocate a named bootmem block
    - Allocate a named bootmem block
namedalloc name size [address]
    - Allocate a named bootmem block with a given name and size at an
      optional fixed address.  Sets environment variables named_block_addr,
      named_block_size to address and size of block allocated.
namedfree
namedfree    - Free a named bootmem block
    - Free a named bootmem block
namedfree name
    - Free a named bootmem block.
namedprint
namedprint    - Print list of named bootmem blocks
    - Print list of named bootmem blocks
namedprint
    - Print list of named bootmem blocks.
freeprint
freeprint    - Print list of free bootmem blocks
    - Print list of free bootmem blocks
freeprint
    - Print list of free bootmem blocks.
read64b
read64b    - read 8 bit word from 64 bit address
    - read 8 bit word from 64 bit address 
read64b addr
    - read 8 bit word from 64 bit address
read64s
read64s    - read 16 bit word from 64 bit address
    - read 16 bit word from 64 bit address 
read64s addr
    - read 16 bit word from 64 bit address
read64l
read64l    - read 32 bit word from 64 bit address
    - read 32 bit word from 64 bit address 
read64l addr
    - read 32 bit word from 64 bit address
write64b
write64b    - write 8 bit word to 64 bit address
    - write 8 bit word to 64 bit address
write64b addr val
    - write 8 bit word to 64 bit address
write64s
write64s    - write 16 bit word to 64 bit address
    - write 16 bit word to 64 bit address
write64s addr val
    - write 16 bit word to 64 bit address
write64l
write64l    - write 32 bit word to 64 bit address
    - write 32 bit word to 64 bit address
write64l addr val
    - write 32 bit word to 64 bit address
read_cmp
read_cmp    - read and compare memory to val
    - read and compare memory to val
read_cmp addr val
    - read and compare memory to val
loop
loop    - infinite loop on address range
[.b, .w, .l] address number_of_objects
    - loop on a set of addresses
mtest
mtest   - simple RAM test
[start [end [pattern]]]
    - simple RAM read/write test
system_red
system_green
usb_green
rs232_green
vpn_green
wlan_green
security
rs232
wlan
system_red_blink
system_yellow_blink
system_green_blink
security_yellow_blink
security_red_blink
usb_green_blink
rs232_green_blink
vpn_green_blink
wlan_green_blink
Detect Reset button
 Success
 Fail
Board model name is CUST_N100WDE
Board model name is CUST_N100DEF
ledtest off <security/usb/rs232/vpn/pcie/wlan/lan/dmz>
ledtest on [system_red|system_green|system_yellow|security_red|security_yellow|usb_green|rs232_green|vpn_green|pcie|wlan_green|lan_green|lan_yellow|dmz_green|dmz_yellow]
Turn off security led.
Turn off usb led.
Turn off rs232 led.
Turn off vpn led.
Turn off wlan led.
system
Turn off sys led.
pcie
Turn off pci led.
e1240 write 0x4 0x3 0x10 0x8808 0xFF0F
e1240 write 0x5 0x3 0x10 0x8808 0xFF0F
e1240 write 0x6 0x3 0x10 0x8808 0xFF0F
e1240 write 0x7 0x3 0x10 0x8808 0xFF0F
Turn off lan led.
mii write 0xD 0x19 0x0002
Turn off dmz led.
e1240 write 0x4 0x3 0x10 0x0000 0xFFFF
e1240 write 0x5 0x3 0x10 0x0000 0xFFFF
e1240 write 0x6 0x3 0x10 0x0000 0xFFFF
e1240 write 0x7 0x3 0x10 0x0000 0xFFFF
mii write 0xC 0x19 0x0002
Turn off all leds.
Invalid Parameter!
ledtest off [system|security|usb|rs232|vpn|pcie|wlan|lan|dmz]
Turn on system red led.
Turn on system green led.
system_yellow
Turn on system yellow led.
security_red
Turn on security_red led.
security_yellow
Turn on security_yellow led.
Turn on usb green led.
Turn on rs232 green led.
Turn on vpn green led.
Turn on pcie led.
Turn on wlan green led.
lan_green
e1240 write 0x4 0x3 0x10 0x9809 0xFF0F
e1240 write 0x5 0x3 0x10 0x9809 0xFF0F
e1240 write 0x6 0x3 0x10 0x9809 0xFF0F
e1240 write 0x7 0x3 0x10 0x9809 0xFF0F
Turn on lan green led.
lan_yellow
e1240 write 0x4 0x3 0x10 0x0908 0x0F0F
e1240 write 0x5 0x3 0x10 0x0908 0x0F0F
e1240 write 0x6 0x3 0x10 0x0908 0x0F0F
e1240 write 0x7 0x3 0x10 0x0908 0x0F0F
Turn on lan yellow led.
dmz_green
mii write 0xD 0x19 0x0233
Turn on dmz green led.
dmz_yellow
mii write 0xD 0x19 0x0322
Turn on dmz yellow led.
e1240 write 0x4 0x3 0x10 0x9899 0xFFFF
e1240 write 0x5 0x3 0x10 0x9899 0xFFFF
e1240 write 0x6 0x3 0x10 0x9899 0xFFFF
e1240 write 0x7 0x3 0x10 0x9899 0xFFFF
mii write 0xC 0x19 0x0233
Turn on all leds.
ledtest on [system_red|system_green|system_yellow|security_red|security_yellow|usb_green 
	 |rs232_green|vpn_green|pcie|wlan_green|lan_green|lan_yellow|dmz_green|dmz_yellow]
wrong parameter!
ledtest off [security|usb|rs232|vpn|cf|voip|pci|wlan|lan|dmz]
./gpioctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
invalid pin number
Read GPIO %u : %u 
./gpioctrl <set> <gpio pin number> <0/1>
Write GPIO %u : %u 
sleep
sleep   - delay execution for some time
    - delay execution for N seconds (N is _decimal_ !!!)
gpioctrl
gpioctrl   - control gpio 
	 Control GPIO. 
	 gpioctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
ledtest
	 ledtest on [system_red|system_green|system_yellow|security_red|security_yellow|usb_green 
	 |rs232_green|vpn_green|pcie|wlan_green|lan_green|lan_yellow|dmz_green|dmz_yellow]
	 ledtest off [security|usb|rs232|vpn|pcie|wlan|lan|dmz]
printmodel
printmodel   - Print board model name.
frtest
frtest   - Test reset button.
	 Press reset button then execute command.
device %d 
whole chip
offset 0x%lx, size 0x%x
'%s' is not a number
No memory for page buffer
Error (%d) reading page %08lx
Page %08lx dump:
	%02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x
OOB:
	%02x %02x %02x %02x %02x %02x %02x %02x
quiet
info
Device %d: %s, sector size %u KiB
device
no devices available
Device %d: %s
No such device
Device %d: %s
dump
scrub
markbad
biterr
lock
unlock
Device %d bad blocks:
  %08lx
clean
NAND %s: 
Warning: scrub option will erase all factory set bad blocks!
         There is no reliable way to recover them.
         Use this command only for testing purposes if you
         are sure of what you are doing!
Really scrub this NAND flash? <y/N>
scrub aborted
.oob
.jffs2
Unknown nand command suffix '%s'.
written
 %d bytes %s: %s
block 0x%08lx successfully marked as bad
block 0x%08lx NOT marked as bad! ERROR %d
tight
status
write NAND flash...
read NAND flash...
verify NAND flash...
NAND write fail.
NAND bad block rate : %d / %d
NAND bad block rate >= %u
NAND bad block rate fail.
NAND flash test pass.
nand
nand    - NAND sub-system
info - show available NAND devices
nand device [dev] - show or set current device
nand read - addr off|partition size
nand write - addr off|partition size
    read/write 'size' bytes starting at offset 'off'
    to/from memory address 'addr', skipping bad blocks.
nand erase [clean] [off size] - erase 'size' bytes from
    offset 'off' (entire device if not specified)
nand bad - show bad blocks
nand dump[.oob] off - dump page
nand scrub - really clean NAND erasing bad blocks (UNSAFE)
nand markbad off - mark bad block at offset (UNSAFE)
nand biterr off - make a bit error at offset (UNSAFE)
nand lock [tight] [status]
    bring nand to lock state or display locked pages
nand unlock [offset] [size] - unlock section
manufacturing data is empty!
basemac
basemac = %s
serno
serno = %s
productID
productID = %s
Usage:getmd_utm [basemac | serno | productID]
ProductID = %s
HWVer = %s
reginfo = %d
numofimages = %d
currimage = %d
maccnt0 = %d
maccnt1 = %d
maccnt2 = %d
maccnt3 = %d
cpuinfo = %04x
freq = %d
ram = %d
flash = %d
poe_pwr = %d
portw1 = 0x%x
portw2 = 0x%x
portlan0 = 0x%x
portlan1 = 0x%x
portlan2 = 0x%x
portlan3 = 0x%x
portlan4 = 0x%x
portlan5 = 0x%x
portlan6 = 0x%x
portlan7 = 0x%x
minipci0 = 0x%x
minipci1 = 0x%x
serialport = %d
Environment updates not supported
Mac address number should be 12 !
Usage:setmd_utm [basemac | serno | productID] [value]
ProductID
HWVer
reginfo
numofimages
currimage
maccnt0
maccnt1
maccnt2
maccnt3
cpuinfo
freq
flash
poe_pwr
portw1
portw2
portlan0
portlan1
portlan2
portlan3
portlan4
portlan5
portlan6
portlan7
minipci0
minipci1
serialport
loadaddr not set due to load reserved memory allocated at 0x%x.
Please refer to the bootloader SDK documentation.
Can't delete "%s"
## Baudrate %d bps not supported
## Switch baudrate to %d bps and press ENTER ...
console_uart
## Error: environment overflow, "%s" deleted
 ** Abort
Environment size: %d/%d bytes
printmd
 - print values of all manufacturing data
printmd name ...
    - print value of manufacturing data 'name'
parameter list: 
ProductID, HWVer, reginfo, numofimages, currimage, basemac,
maccnt0, maccnt1, maccnt2, maccnt3, serno, cpuinfo, freq, ram,
flash, poe_pwr, portw1, portw2, portlan0, portlan1, portlan2,
portlan3, portlan4, portlan5, portlan6, portlan7, minipci0,
minipci2, serialport
setmd
 - set manufacturing data
setmd name value ...
    - set manufacturing data 'name' to 'value ...'
parameter list: 
ProductID, HWVer, reginfo, numofimages, currimage, basemac,
maccnt0, maccnt1, maccnt2, maccnt3, serno, cpuinfo, freq, ram,
flash, poe_pwr, portw1, portw2, portlan0, portlan1, portlan2,
portlan3, portlan4, portlan5, portlan6, portlan7, minipci0,
minipci2, serialport
savemd
savemd - save manufacturing data to persistent storage
setmd_utm
 - set manufacturing data
setmd name value ...
    - set manufacturing data 'name' to 'value ...'
parameter list: 
basemac,serno
getmd_utm
 - print values of all manufacturing data
printmd name ...
    - print value of manufacturing data 'name'
parameter list: 
basemac,serno
printenv
printenv- print environment variables
    - print values of all environment variables
printenv name ...
    - print value of environment variable 'name'
setenv  - set environment variables
name value ...
    - set environment variable 'name' to 'value ...'
setenv name
    - delete environment variable 'name'
saveenv
saveenv - save environment variables to persistent storage
run     - run commands in an environment variable
var [...]
    - run the commands in the environment variable(s) 'var'
- No help available.
Unknown command '%s' - try 'help' without arguments for list of all known commands
version
version - print monitor version
echo
echo    - echo args to console
[args..]
    - echo args to console; \c suppresses newline
help    - print online help
[command ...]
    - show help information (for 'command')
'help' prints online help for the monitor commands.
Without arguments, it prints a short usage message for all commands.
To get detailed help information for specific commands you can type
'help' with one or more command names as arguments.
?       - alias for 'help'
Cannot initialize the list of devices!
Using default environment
Timeout writing to Flash
Flash not Erased
Can't write to protected Flash sectors
Outside available Flash
Start and/or end address not on sector boundary
Unknown Vendor of Flash
Unknown Type of Flash
General Flash Programming Error
%s[%d] FIXME: rc=%d
flash.c
%2ld
.%ld
 %cB%s
0123456789abcdefghijklmnopqrstuvwxyz
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
<NULL>
unknown
PAL rev: %d.%02d, MCU rev: %d.%02d, CPU voltage: %d.%02d
%d 0.%.2d 
%d 1.%.2d 
Boot    
[%x] 
*** reset failed ***
[DEBUG STUB]Output too long: %d
!Core XX 
taking focus.
!Core is not in the exception handler. Focus not changed.
!Focus core was added to the masked.
[DEBUG STUB]Query #%d is not valid
[DEBUG STUB]Register #%d is not valid
[DEBUG STUB]Unknown debug command: %s
FAT32   
FAT16   
FAT12   
Invalid FAT entry
            %s%c
 %8ld   %s%c
%d file(s), %d dir(s)
Error reading cluster
reading %s
No current device
Interface:  
SATA
SCSI
ATAPI
  Device %d: 
No valid FAT fs found
Partition %d: Filesystem: %s "%s"
** Can't read from device %d **
** No FAT signature found on device %d **
** Partition %d not valid on device %d **
Partition Map for 
UNKNOWN
 device %d  --   Partition Type: %s
## Unknown partition table
not available
(%d:%d) 
Model: %s Firm: %s Ser#: %s
Vendor: %s Prod.: %s Rev: %s
            Type: 
Removable 
Hard Disk
CD ROM
Optical Device
Tape
# %02X #
            Supports 48-bit addressing
            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)
            Capacity: not available
            MWDMA mode: %d
            UDMA mode: %d
** Can't read partition table on %d:%d **
bad MBR sector signature 0x%02x%02x
 Extd
%5d		%10d	%10d	%2x%s
    1		         0	%10ld	%2x
Partition     Start Sector     Num Sectors     Type
hd%c%d
sd%c%d
usbd%c%d
docd%c%d
xx%c%d
U-Boot
### Warning: RTC oscillator has stopped
Attempt to read outside the flash area
NAND read from offset %x failed %d
Skipping bad block 0x%08x
Attempt to write non page aligned data
Attempt to write outside the flash area
NAND write to offset %x failed %d
Skip bad block 0x%08x
Warning: Erase size 0x%08lx smaller than one erase block 0x%08x
         Erasing 0x%08x instead
Skipping bad block at  0x%08x                                            
%s: MTD get bad block failed: %d
%s: MTD Erase failure: %d
%s: MTD writeoob failure: %d
Erasing at 0x%x -- %3d%% complete.
 Cleanmarker written at 0x%x.
(2<FPZ
!2BK
|cvmx_l2c_get_num_assoc
cvmx_l2c_get_set_bits
U-Boot 1.1.1 (Development build, svnversion: u-boot:exported, exec:exported) (Build time: Feb 11 2011 - 11:42:25)
Unand
nand_get_flash_type
e03f<ij??ji<f30ef30e?ji<<ij?e03f
i<?j0ef33fe0j?<i
j?<i3fe00ef3i<?jj?<i3fe00ef3i<?j
i<?j0ef33fe0j?<i
f30e?ji<<ij?e03fe03f<ij??ji<f30e
gqr<
$/o|
f-=v
mj>zjZ
l6qnk
IiGM>nw
PPP`<(<-  '
0123456789abcdef
Bbt0
1tbB
        
ftbootdelay=5
baudrate=115200
download_baudrate=115200
bootloader_flash_update=protect off $(uboot_flash_addr) +$(uboot_flash_size);erase $(uboot_flash_addr) +$(uboot_flash_size);cp.b $(fileaddr) $(uboot_flash_addr) $(uboot_flash_size);run nuke_env
burn_app=erase $(flash_unused_addr) +$(filesize);cp.b $(fileaddr) $(flash_unused_addr) $(filesize)
bf=bootoct $(flash_unused_addr) forceboot numcores=$(numcores)
nuke_env=protect off $(env_addr) +$(env_size); erase $(env_addr) +$(env_size)
linux_cf=fatload ide 0 $(loadaddr) vmlinux.64;bootoctlinux $(loadaddr)
ls=fatls ide 0
autoload=n
ddr_verbose=yes
autotest=1
ipaddr=10.0.0.30
serverip=10.0.0.60
ethact=octeth1
(((((
AAAAAA
BBBBBB
@@-$
<4B	8
<4B	0
<4B	(
<4B	 
<4B	
!$Bf
	pD 
@$H'
$BcD
	pD 
2>4B
@dc'
!$c_|
(-$h"
b -$
*>4B
b0-$
%|Ex
@(-|
  -*
04B 
 -'9
 -'9
 -'9
 !'9
 -'9
 -'9
t$i"
 -'9
 -'9
@ -$
(-4c
(-4c
$|B)C$
 -'9
04c!
-4B!
 -$B
04c!
04c!
-4B!
-4B!
04B!
(-|P
&|Px
'9:(
$Q:(
|B0C<
:|B(
$P:(
m$P:(
$P:(
$P:(
$P:(
$P:(
$P:(
$P:(
$P:(
'9G(
$QG(
|B0C<
:|B(
$PG(
m$PG(
$PG(
$PG(
$PG(
$PG(
$PG(
NP !)
	L85)
h@	x
07{ 
07{!
07{"
07{#
07{$
07{!
07{"
07{#
07{$
07{!
07{"
07{#
07{$
07{!
07{"
07{#
07{$
	NB1)
$B"x
$B"D
@(-,B
@(-$
@0-*"
@ -&
3$TM
@ -$E
'9&,
'9&,
'9&,
'9&,
'9&,
'9&,
'9&,
'9&,
$HNh
I$EO
C$EO
3$EO
-$EPg
"$EP
$EP/
$EPG
	$EP
&$UQ`
 8-$
 0-$
 0-$
@H-$
$CR8
@H-$
$CR@
@(-.
$ERh
$ES@
$ET`
$EWx
$EVh
}$EV
r$EW`
j$EW
h$ER
e$ER
b$ER
_$ER
\$ER
Y$ES(
V$ESX
S$ESp
P$ES
M$ES
J$ES
G$ET
D$ET0
A$ETH
>$ET
;$ET
8$ET
5$EU
2$EU0
/$EUH
,$EU`
)$EU
&$EU
#$EV
 $EV(
$EVH
$EW(
$EWH
	&dX0*"
$cX@
$cXx
C$EO
/$EO
)$EPg
$EP/
$EPG
$ERh
$ES@
$ET`
$EWx
$EVh
v$EW`
n$EW
l$ER
i$ER
f$ER
c$ER
`$ER
]$ES(
Z$ESX
W$ESp
T$ES
Q$ES
N$ES
K$ET
H$ET0
E$ETH
B$ET
?$ET
<$ET
9$ET
6$EU
3$EU0
0$EUH
-$EU`
*$EU
'$EU
$$EV
!$EV(
$EVH
$EW(
$EWH
	$EW
	$EZ_
0-0B
$c\x
 !&1
0-0B
$c]P
0-0B
E4BLF
$UbP
6r# 
e(!|
e(!|
@0-&
9H!%)
'9Y\
$Cm 
'9Y\
$Cm 
YP!%J
 -$	
9H!%)
b4cM
(-*"
#$Du
 -&1
$Wv@
$^vx
$Bvp
b4cM
9H!%)fh,
 -|PY
D #|Pz
	$D{
;dC'
	$D{
@8-0C
4QK@
`(-f
@(-f
`(-rb
` -$
` -$
` -$
	$D}X
'$}X
$D}p$
 -$D}
@(-*
(-$D}
$CR8
 #.b
@ -.B
@8-(B
#|b	
C0!|
` -0b
(-*"
>pB:2
>pB>2
$4Bh
 -&G
@GH"
@@-*b
@8-*b
 (-f
('f1
4BUU
84BUU
4BUU
84BUU
UU4BUU
84BUU
84UUU<
U4BUU
84BUU
 (-<
  -<
  -<
@ -(B
@ -$
	rr0
$Tv@
@ -$
@(-/
  -&
  -$
  -$
  -$
@0-&
b8$$
b8$$
 -8B
@ -&b
	|C 
 -.B
	|C 
 -.B
	|Db
	|Db
	|Db
	|Db
(-$C
@ -~%
@ -&1
@ -*"
 -$C
$Cnp
$DR8$
$Cnp
(-*"
$Enp$E
 '9.$
 '9+
 '9+
(-$DQ
$DR8$
 -*"
$ER8$EQ
 '9.$
 -$C
 '9.$
h$FQ
 '9>
 '9>
 '9>
@ -$
!$TBP
$TBP
@ -,B
 -$S
 $SBP
@ -&
 $VBP
@ -$
@ -$
@ -$
@ -$
@ -$
 '9Sp
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
@ -$
 '9Sp
  -$
  -&
$Tv@
 $VcX
@ -$
 '9c
 '9c
 '9cX
 '9j
@(-$
 '9j
 '9j
 '9j
 '9k$
 '9k$
 '9j
@(-$
 -&D
 '9p
 '9j
 '9p
  -$
 '9p
(-$D
@0-$
9H!%)j$
!$ci\
!$ch
!$ch
0-$	
@ -$
`(-$
D $@
 @-f1
E4BLF
0pe 
0pe 
E(!$
@ -$
  -$
VHP<
e(!&
d !~
e(!&
T(!~
d !~
d !~
8#&1
` -~
` -~
8#&1
`(-$
$BHX
0-$E
!$cI
$BHp
0-$E
0-$E
0-$E
r (,$
 (-2"
$BHp
0-$E
D $@
 -&1
!$c(
!$c(
!$c(t$
@(-$B
E #(
p(#(
p(#(
 -0b
@ -$
# !$
P(#(
`(-,
@ -$
e !r"
LI4BST
 -&%L
"H!<
 -,B
 (-'
 (-'
` -&1
` -$
&|cz
@ -$
@ -$
@ -$
@ -$
  -$
  -$
  -$
  -$
  -$
@0-&
F0%$
84Bk
%6B4
%6$@T<
@6$@T
d6$@T
6$@T<
e(%6$@T
<4B	8
<4B	0
<4B	(
<4B	 
<4B	
<4B	
@8-r
@$I'
-~Cz
@dc'
9H!%)
@8-0F
9H!%)
@8-0F
$'9/
8-$	
b(-$
$'92
b0-$
`(-|c
$'90
$'92
%|Ex
@(-|
$'92
 (B'
 (B'
$'97
04B 
$'90
$'92
Q -6
 pb8
$'92
$'92
$'9.
$'96h
$'92
$'96h
$'96h
$'9.
$'92
$'96h
$'96h
$'9-
$'90
$'90
$'92
$'9-
$'90
$'92
$'9-
$'9.
$'9.
$'9/
(-'92
$'9.
$'9.
$'92
$'92
$'9-
@ -$
$'90
$'90
T|B)C
$$R0
$'92
(-|B)C
$$R0
$'92
$'9.
$'9.
04c!
04B!
$$R.
04c!
04B!
$'9.
04c!
04B!
04B!
04B!
$'97
&|Px
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
x4B0
&|Bz
&|Bz
$'9I
$'9I
$'9I
$'9I
$'9I
:|B0C8B
:|B(
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9I
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
:|B0C8B
:|B(
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9Z
$'9`
 -2#
$'9`
-~#x
$'9q$
-|P8
|BcC
 !$B
R|Cz
`|bz
$|C8
'9q$
/|B8
$'9p
/|c8
 -~Q
/|B8
$'9p
/|c8
 -~Q
$$Pr\
C(%2b
/|B8
/|c8
 -~Q
`|bz
/|B8
x~B8
/|c8
 -~Q
`|bz
 -&R
9H!%)Q
 %0b
!$cO
9H!%)OX
 %0b
$'9K
&|cz
&|cz
$'9K
&|cz
0!$B
|CJG
&|cz
H:|b
!$cB
:|B 
$'9M
|BxC0Q
 (-6
p@(,
b(-$
b(-$
x4B0
x4B0
&|cz
x4B0
@ -<
U4BUU
84BUU
U4cUU
84cUU
20!~D
0!~$
"'9M
$'9M
$'9M
$'9M
$ERh
$ES@
$ET`
$EWx
z,b'
r,b'
s,b'
$EVh
k,b'
t,bN!
v$EW`
n$EW
l$ER
i$ER
f$ER
c$ER
`$ER
]$ES(
Z$ESX
W$ESp
T$ES
Q$ES
N$ES
K$ET
H$ET0
E$ETH
B$ET
?$ET
<$ET
9$ET
6$EU
3$EU0
0$EUH
-$EU`
*$EU
'$EU
$$EV
!$EV(
$EVH
$EW(
$EWH
	$EW
@(-2
 -&%
 -&%
 -&%
 -&%
 -&%
 -&%
 -&%
&|cz
e($<
4BA	
&|cz
&|cz
$'9M
$'9M
$'9M
$'9M
x4B0
@(-'
$ERh
$ES@
$ET`
$EWx
z,b'
r,b'
s,b'
$EVh
k,b'
t,bN!
v$EW`
n$EW
l$ER
i$ER
f$ER
c$ER
`$ER
]$ES(
Z$ESX
W$ESp
T$ES
Q$ES
N$ES
K$ET
H$ET0
E$ETH
B$ET
?$ET
<$ET
9$ET
6$EU
3$EU0
0$EUH
-$EU`
*$EU
'$EU
$$EV
!$EV(
$EVH
$EW(
$EWH
	$EW
4B9@
L@#X
` -,b
P-|J
H-|I
H-ek
H--b
%H-1k
`H-eJ
&H-1J
@ -0
	4D 
R !$b
(-~&
 (-~
&|cz
$'9O
YP!%J
yX!%k
8-@#
8-@#X
(-2F
x4B0
x4B0
x4B0
x4B0
&|cz
x4B0
@ -<
&|cz
&|cz
$'9Q|
$'9Q|
&|cz
&|cz
$'9Q|
$'9Q|
&|cz
&|cz
&|cz
&|cz
$'9Q|
$'9Q|
$'9Q|
&|cz
$'9Q|
&|cz
&|cz
x'9Q|
&|cz
&|cz
&|cz
&|cz
&|cz
&|cz
'9Q|
'9Q|
$'9Q|
$'9Q|
&|cz
&|cz
4BB@
@@-|
?|Hz
&|cz
?|Hz
e&u0
`@-$
?|Hz
&|cz
&|cz
@0-&B
` -2
x4B0
x4B0
` -$
@ -|
34c33
84c33
g4Bi
0-0B
|PJG
@(-<
x4B0
x4B0
x4B0
34c33
84c33
g4Bi
x4B0
@ -$
|D)G
x4B0
x4B0
@ -|
x4B0
|PJG|P
0-0B
|PJG
b(-$
.|D!
n|D)G
x4B0
@ -$
x4B0
@ -|
x4B0
@ -$
@ -|
@ -$
x4B0
@ -|
x4B0
|PJG
.|D!
n|D)G
x4B0
@ -$
x4B0
@ -|
x4B0
84Bk
84Bk
x4^4
@(-'
`(-'
b4cM
('9 
('9 
('9 
('9 
('9 
('9 
('9 
('9 
('9 
('9 
$|TB
+~Ts
l|TR
+~Ts
b4cM
x4B0
 -'9
0-0B
@(-<
(-$B
+|SJG<
0-0B
x4B0
|PIG
|PIG
('9 
0-0B
('9 
0-0B
|PIG
('9 
0-0B
@(-<
(-2c
-|P 
~0AG
(-|PbG
(-|P
#|R 
#|RAG
|RrG<
.0~e
@(-$
1P2%
('9 
$|TB
+~Ts
x4B0
x4B0
x4B0
@ -~
x4B0
x4B0
x4B0
x4B0
x4c0
0-6#
|BcC
 -&R
 @-&1
$T^ 
($R^D
('9^D
('9^
('9^ 
('9]
  -'9^
('9]
($T^D
-'9^ 
('9^ 
('9]
($P^
('9]
('9^ 
('9^ 
('9]
($R^ 
('9]
('9^D
('9^
('9^ 
('9]
('9^D
($P^
  -'9]
($P^
 (-$
($W^D
($B^
('9^ 
('9^D
-'9^D
($S^
('9]
('9^D
('9^
'9^D
('9^ 
($P]
('9^h
!$cu$
&|cz
&|cz
&|cz
&|cz
$'9S`
$'9S`
$'9S`
&|cz
$'9S`
$'9S`
&|cz
&|cz
$R:0
x4c0
$d:X
@0-r
 -&"
 -|DZ
&|cz
$'9S`
4c>@
*4ct@
-|U8
-|R8
<|dx
pc9r
|BcC
 !$c
R|bz
`|bz
/|B8
D~B8
/|c8
!$cV
(-pB(
  -<
(-pB(
&|cz
&|cz
&|cz
&|cz
YP!%JS|0
  -r
@ -@
&|cz
&|cz
@ -2"
  -&"
 !&"
  -&"
$|D9
84Bk
x4B4
84Bk
x4B4
&|cz
&|cz
&|cz
$'9UD
$'9UD
&|cz
$'9UD
$'9UD
$'9UD
&|cz
84Bk
x4B4
`(-|
|QJG|Qc
84Bk
x4B4
@(-2w
@ -0B
84Bk
x4B4
84Bk
x4B4
G|DB
|b)G
@(-&
!$c2
@(-|P
$B<h
$B<p
!$c.
#|DR
&|cz
&|cz
&|cz
$'9W(
&|cz
&|cz
'9W(
"|P@
84Bk
x4B4
84Bk
x4B4
84Bk
x4B4
@ -|
84Bk
x4B4
84Bk
x4B4
84Bk
x4B4
84Bk
x4B4
84Bk
x4B4
@ -|
@ -$
@0-p
P-$	
 (-$
 (-$
 (-$
 (-$
 (-$
 (-$
 (-$
@(-$
  -4
  -4
  -4
&|cz
  -$
  -$
  -$
  -$
  -$
  -6
  -6
  -6
  -6
  -6
  -6
  -6
0-&s
  -$
  -&
  -&
  -$
  -$
  -$
 (-r$
 0-|
b4BM
b4BM
`(-|
b4BM
@(-|
 -rC
@(-|
Q0-$
b4BM
C0-|
|DZG|DB
&|cz
$'9eh
@8BN+,B
@(-$
@(-$
$'9Z
$'9Z
$'9Z
  -r
x4B0
,~0:
	$WA
0$TA
-$TA
*$TB
'$TB
$$TB
!$TB
$TB 
$TB(
$TB0
$TB8
$TB@
$TBH
	$TBP
$TBX
$TB`.
$RB8
$RBh$RBp2$
$BBx
$RBH2$
$RBH$BB
{$RBH$BB
r$RBH$
d$RA
Q$RA
G$RA
>$RA
$BBx
5$RA
($WB
&$WB
$RB`
3|C8
2|C8
1|C8
0|C8
!|g#
&|cz
$'9\
$'9\
$'9\
$'9\
!|C8
-|C8
&|cz
&|cz
$'9\
$'9\
$'9\
$'9\
&|cz
&|cz
;|PI
x4B0
x4B0
0|p(
@P-$
YP!%J
@@-$
@(-$
 !0B
  -$
  -$
 0-$
&|cz
x4B0
$'9^
$'9^
$'9^
`0-$
 -rB
$'9^
&|Bz
x4B0
*4B0
&|cz
&|Bz
&|Bz
&|cz
9H!%)
 %0b
d !$
 %0b
 %0b
 %0b
!|SxC
,'9$
0-&1
@(-$B
 -&E
,'9"
dpC(
,$B)
,'9'T
e(%'
e(%'
,$B)
,'9$
,'9'T
'$Gh
e(%'
'$Gh
e(%'
,$B$
 -$b
,'9$
,'9$
,'9*
,'9*
,'9*
,'9"
 %0b
(%0b
,'9:
 %0b
$BIh
 %0b
 %0b
 %0b
 %0b
 %0b
0-&s
,$B:
,'9:
@ -$
@0-$B
@ -&e
 %0b
	$DJ
 %0b
@ -$B
,$UG
,$B:
 %0b
 %0b
,'9:
,'9G
@0-$
9H!%)
@!$c
H-}'<
@(-$
@(-<
-4QB@
!$ct
NH1&
U4cUU
84cUU
$BO8
$BO@
 -$B
$BOH
$BOX
$BOp
,'9s
,'9vl
 !&E
,'9vl
,'9vl
,'9s
U4cUU
84cUU
,'9s
,'9vl
U4cUU
84cUU
,'9s
,'9vl
,'9s
,'9s
,'9vl
 !&e
,'9vl
9H!%)ed$
`0-$c
84cZS
  -$
 -&B
 -&e
4BSc
` -<
84cZS
 -&e
  -$
4BSc
4BSc
` -$
!$cV,
(-$D
@ -'
` -$
`8-&
YP!%JA
I4B$
!$B@(0
!$B@
!$B?
!$B?
!$c?
!$c?
!$c?
!$c?x
YP!%J?
8-$	
@ -'9
YP!%J8
 -rC
@0-&
(-&s
@0-&s
@0-&
(!$c
@ -pP:2
pP:2
l,B11
$BYX
 %0b
MpB0r
	pb0r'9
yX!%k
0-,S
@(-$
@(-$
@(-$
@(-$
@(-$
g8#$
@(-$
@(-$
@(-$
@(-$
@(-$
@(-$
@(-$
@(-$
@(-$
U *$
@(-$
@(-$
@(-$
@(-$
@(-$
  -$
  -|B
@ -0
@ -$
0!&s
r0!&
  -$
(-0C
` -$
` -$
` -$
` -$
@(-0C
0!&s
0!&s
@ -$
 (-$
  -$
@8-&T
  -$
  -$
  -$
  -$
0$B	
` -$
` -$
` -$
` -0C
"B|E
 -$B
` -$
` -$
` -$
` -&
` -&
0-&R
@ -$
E(!pc
0-&R
@ -$
(-&1
`(-$
` -2%
` -$
` -$
` -$
` -$
` -$
` -$
` -'
(B1#
(%1"
YP!%J
 -0b
4$B#
0$B"
 !0e
0$B#
$R`x
$U`P
$BaH
 !2E
 !2E
 !2E
0$V*l
0'9*l
$Bb 
(-$	
0'9.
0'9.
0'9$
0'9#
0'9#
0'9'
0'9'
0$B.
0$B-H
0$Y$
0'97
0$B?p
$Deh
  -|
@0-$
@0-rP
@0-$
0'9CD
0$B[
0$BR$
0$B^l
0$BT
0$BU
0$BC
0$BK
$Sj`
0$UCD
$Tk(
$FkX$Fk`
dpC(
$Bl 
$Bl 
0$^CD
 8-&
0'9CD
u$WV
0-*b
0$BV
yX!%k
&pB8
&pB8
&pB8
&pB8
&pB8
&pB8
&pB8
&pB8
C &%)
&pB8
b &$
!$c}
(%rb:2
!$c|
9H!%)z
!$cy
CP!$
bP-$
$Lr(
"H$$
h-1$
p-18
8#1"
0'9n
0'9n
%pb8
$QrP
0'9n
@ -$
@ -&v
@ -$
(-&v
0$Qn
@ -|
0'9n
0'9n
@ -'
!$Bm
0'9x
0$Bw
0$Bw
0'9xx
0'9xx
0$Rx
$BrX
$Brx
d !|
|c!C,b
0'9xx
@0-$
$Bs 
$BsH
$Bsp
|B!C
0'9xx
0'9x
0'9xx
0'9x
0'9x
0$Px
0#0b
@%$c
 !$b
V$Bs
"H%%J
f(#$
g(#$
$(#$b
d(#$
 -'9
@0-$
@0-$
0$Px
9H!%)6
@<pE
!$c5
!$c5
!$c5
!$c3
!$c2
3D4B
3D4B
 -,b
$Qu0
	$QuH
$Qu`
$Qup
$QH 
$RH $
$Bwp
  -&
@0-$
(-4B
 (-$
`(-&
@0-'
 -&e
0-&0
 (-&
 -&s
  -&
]4BJ
@ -&
@ -&
@ -$
`0-$
@ -&"
@ -&"
@ -&"
@ -&"
@ -&"
@ -&"
@ -&"
 0-$
  -$
  -$
(-&b
YP!%J
ZZ4c
 0-&
@ -<
  -,B
 -,B
-0B?
$$C@
3D4B
3D4B
 4B&
Z<5m
	|C 
Z<5m
	|C 
 -."
@ -&b
 -'9
 -."
@ -&e
00#,
@0-$
@0-$
@0-$
,'9%
'9'h
'9'h
0-$	
'9'h
!|TxC
r"8r
%~c:
%~b:
,'9%
,$T%
,$T%
@ -$
'9)P
'9'h
'9'h
'94|
'9'h
$B'h
$B4|
@(-,
`0-0
$ !$
$B'h
,$B%
@(-,
~C:C
D~C:C
`0-0
'9)P
'9Pt
 -~%
 -~%
'9Pt
verify
Bad magic number
Bad header crc
Bad data crc
Bad image type
Empty Script
## Executing script at %08lx
autoscr
autoscr - run script from memory
[addr] - run script starting at addr - A valid autoscr header must be present
Usage:
## Starting application at 0x%08lX ...
## Application terminated, rc = 0x%lX
go      - start application at address 'addr'
addr [arg ...]
    - start application at address 'addr'
      passing 'arg' as arguments
reset
reset   - Perform RESET of the CPU
Error: Bad gzipped data
Error: gunzip out of data in header
Error: inflateInit2() returned %d
Error: inflate() returned %d
Error: Destination not large enough
Error: Source truncated
Error: inflateEnd() returned %d
Uncompressing 0x%x@0x%x to 0x%x@0x%x
filesize
Uncompressed 0x%x bytes
Gunzip failed
Invalid number of arguments.
gunzip
gunzip  - Uncompress an in memory gzipped file
<source address> <source len> <destination address> <destination len>
gunzip <source named block> <destination named block>
    - Uncompresses a gzip file in memory. The source and destination
      may either be a named block or an address and size pair. All
      numbers are in hex.
List of available devices:
%-8s %08x %c%c%c 
coninfo
coninfo - print console devices and informations
Reset RTC...
## Bad date format
unknown 
Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d
Tues
Wednes
Thurs
Satur
date    - get/set/reset date & time
[MMDDhhmm[[CC]YY][.ss]]
date reset
  - without arguments: print date & time
  - with numeric argument: set the system date & time
  - with 'reset' argument: reset the RTC
Unknown customer tuple type
Unknown tuple type
EEPROM_CLOCK_DESC_TYPE
EEPROM_NULL_TYPE
EEPROM_BOARD_DESC_TYPE
EEPROM_CHIP_CAPABILITY_TYPE
EEPROM_MAC_ADDR_TYPE
EEPROM_VOLT_MULT_TYPE
EEPROM_RLDRAM_DESC_TYPE
EEPROM_DDR_CLOCK_DESC_TYPE
EEPROM_MAX_TYPE
EEPROM_CUSTOMER_RESERVED_START
EEPROM_CUSTOMER_RESERVED_END
EEPROM_END_TYPE
Deleting %s (0x%x) tuple at address 0x%x, length %d
Copying tuple type %d (len 0x%x)to addr: 0x%x
Error writing tuple type %d to addr: 0x%x
Writing tuple type %d to addr: 0x%x
read
EEPROM @0x%lX %s: addr %08lx  off %04lx  count %ld ... 
done
write
help
Board types: 
CVMX_BOARD_TYPE_SIM
CVMX_BOARD_TYPE_NULL
CVMX_BOARD_TYPE_EBT3000
CVMX_BOARD_TYPE_KODAMA
CVMX_BOARD_TYPE_NIAGARA
CVMX_BOARD_TYPE_NAC38
CVMX_BOARD_TYPE_THUNDER
CVMX_BOARD_TYPE_TRANTOR
CVMX_BOARD_TYPE_EBH3000
CVMX_BOARD_TYPE_EBH3100
CVMX_BOARD_TYPE_HIKARI
CVMX_BOARD_TYPE_CN3010_EVB_HS5
CVMX_BOARD_TYPE_CN3005_EVB_HS5
CVMX_BOARD_TYPE_KBP
CVMX_BOARD_TYPE_CN3020_EVB_HS5
CVMX_BOARD_TYPE_EBT5800
CVMX_BOARD_TYPE_NICPRO2
CVMX_BOARD_TYPE_EBH5600
CVMX_BOARD_TYPE_EBH5601
CVMX_BOARD_TYPE_EBH5200
CVMX_BOARD_TYPE_BBGW_REF
CVMX_BOARD_TYPE_NIC_XLE_4G
CVMX_BOARD_TYPE_EBT5600
CVMX_BOARD_TYPE_EBH5201
CVMX_BOARD_TYPE_EBT5200
CVMX_BOARD_TYPE_CB5600
CVMX_BOARD_TYPE_CB5601
CVMX_BOARD_TYPE_CB5200
CVMX_BOARD_TYPE_GENERIC
CVMX_BOARD_TYPE_MAX
CVMX_BOARD_TYPE_CUST_DEFINED_MIN
CVMX_BOARD_TYPE_CUST_WSX16
CVMX_BOARD_TYPE_CUST_NS0216
CVMX_BOARD_TYPE_CUST_NB5
CVMX_BOARD_TYPE_CUST_WMR500
CVMX_BOARD_TYPE_CUST_ITB101
CVMX_BOARD_TYPE_CUST_NTE102
CVMX_BOARD_TYPE_CUST_AGS103
CVMX_BOARD_TYPE_CUST_GST104
CVMX_BOARD_TYPE_CUST_GCT105
CVMX_BOARD_TYPE_CUST_AGS106
CVMX_BOARD_TYPE_CUST_SGM107
CVMX_BOARD_TYPE_CUST_GCT108
CVMX_BOARD_TYPE_CUST_AGS109
CVMX_BOARD_TYPE_CUST_GCT110
CVMX_BOARD_TYPE_ARROW
CVMX_BOARD_TYPE_SBOX3
CVMX_BOARD_TYPE_SBOX4
CVMX_BOARD_TYPE_CUST_DEFINED_MAX
CVMX_BOARD_TYPE_CUST_PRIVATE_MIN
CVMX_BOARD_TYPE_CUST_N100
CVMX_BOARD_TYPE_CUST_PRIVATE_MAX
Unsupported Board
	%10s:	 %d
delete
Error deleting tuple (address %d (0x%x).
display
==========================================
%s (0x%x) tuple found: at addr 0x%x
type: 0x%x, len: 0x%x, csum: 0x%x, maj_ver: %d, min_ver: %d
WARNING: tuple version mismatch, display may be wrong. (compiled for version: %d)
DDR clock: %d Mhz (raw: 0x%x)
CPU ref clock: %d Mhz (raw: 0x%x)
SPI clock (deprecated): %d Mhz (raw: 0x%x)
DFA ref clock: %d Mhz (raw: 0x%x)
Board type: %s (0x%x) 
Board revision major:%d, minor:%d
CVMX_CHIP_SIM_TYPE_DEPRECATED
CVMX_CHIP_TYPE_NULL
CVMX_CHIP_TYPE_OCTEON_SAMPLE
CVMX_CHIP_TYPE_MAX
Unsupported Chip
Chip  type (deprecated): %s (0x%x)
Chip  revision (deprecated) major:%d, minor:%d
Board ser #: %s
Coremask: 0x%04x, voltage_x100: %d, cpu_freq_mhz: %d
MAC base: %02x:%02x:%02x:%02x:%02x:%02x, count: %d
Voltage: %d millivolts
CPU multiplier: %d
clock
Setting clock descriptor...
ddr: %d, cpu ref: %d, dfa ref: %d spi: %d
Using version 1 clock descriptor for ebt3000 board
board
Setting board descriptor...
Board type: %d, rev: %d.%d, serial: %s
capability
Setting chip capability descriptor...
Setting mac address descriptor...
Setting mac count to: %d
volt
Setting voltage to %d millivolts and cpu multiplier to %d
eeprom
eeprom  - EEPROM sub-system
read  addr off cnt
eeprom write addr off cnt
       - read/write `cnt' bytes at EEPROM offset `off' to/from memory address 'addr'
tlv_eeprom
tlv_eeprom  - EEPROM data parsing for ebt3000 board
tlv_eeprom [display|set|delete|help]
tlv_eeprom display
       - display contents of eeprom data structures
tlv_eeprom set
       - set contents of eeprom data structures, values in hex or decimal
       set clock [ddr_clock in Mhz] [cpu_ref_clock in Mhz * 8] [dfa_ref_clock in Mhz * 8] [spi_clock in Mhz]
       set board [board type] [major rev] [minor rev]  [serial string]
       set mac    [mac base x:x:x:x:x:x] [mac addr count]
       set capability [coremask_override] [voltage * 100] [cpu core freq in Mhz]
       set volt [voltage in millivolts] [cpu multiplier]
tlv_eeprom delete [tuple addr]
       - deletes tuple at address and compacts any following tuples.
Chip types have been deprecated, and can no longer be set.
(use tlv_eeprom help for list of board types)
## No elf image at address 0x%08lx
ELF file is 32 bit
ELF file is 64 bit
ERROR: invalid elf class
## Not an Executable elf image at address 0x%08lx
Processing PHDR %d
  Loading %lx bytes at %llx
  Clearing %lx bytes at %llx
Load
Clear
%sing %s @ 0x%08qx (0x%lx bytes)
%sing %s @ 0x%08lx (%ld bytes)
## Starting application at 0x%08lx ...
## Application terminated, rc = 0x%lx
bootelf
bootelf - Boot from an ELF image in memory
 [address] - load address of ELF image.
 If address is 0, default load address is used.
usage: fatinfo <interface> <dev[:part]>
** Invalid boot device **
** Invalid boot device, use `dev[:part]' **
** Unable to use %s %d:%d for fatinfo **
usage: fatls <interface> <dev[:part]> [directory]
** Unable to use %s %d:%d for fatls **
No Fat FS detected
usage: fatload <interface> <dev[:part]> <addr> <filename> [bytes]
** Unable to use %s %d:%d for fatload **
** Unable to read "%s" from %s %d:%d **
%ld bytes read
0x%lX
fileaddr
filename
usage: fatloadalloc <interface> <dev[:part]> <addr> <filename> [alloc_name]
ERROR getting filesize for file: %s
Error allocating named block: name: %s, address: 0x%08x
Allocated block %s at 0x%08x, %ld bytes read
fatloadalloc
fatloadalloc - load binary file from a dos filesystem, and allocate
          a named bootmem block for file data
<interface> <dev[:part]>  <addr> <filename> [alloc_name]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from dos filesystem and allocate named bootmem block
      Sets environment variables filesize, fileaddr, filename
      If addr is 0, then load address will be allocated.
      If alloc_name is omitted, the filename will be used as the name of the block
fatload
fatload - load binary file from a dos filesystem
<interface> <dev[:part]>  <addr> <filename> [bytes]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from dos filesystem
      Sets environment variables filesize, fileaddr, filename
      If addr is 0, then file will be loaded to the default load address
fatls
fatls   - list files in a directory (default /)
<interface> <dev[:part]> [directory]
    - list files from 'dev' on 'interface' in a 'directory'
fatinfo
fatinfo - print information about filesystem
<interface> <dev[:part]>
    - print information about filesystem from 'dev' on 'interface'
Error: end address not on sector boundary
Error: end sector precedes start sector
Error: cannot span across banks when they are mapped in reverse order
Error: start and/or end address not on sector boundary
%sProtect Flash Bank # %ld
Bad sector specification
%sProtect Flash Sectors %d-%d in Bank # %d
bank
Only FLASH Banks # 1 ... # %d supported
missing or unknown FLASH type
Erase Flash Sectors %d-%d in Bank # %d 
Erase Flash Bank # %ld 
Bank # %ld: 
flinfo
flinfo  - print FLASH memory information
    - print information for all FLASH memory banks
flinfo N
    - print information for FLASH memory bank # N
erase
erase   - erase FLASH memory
start end
    - erase FLASH from addr 'start' to addr 'end'
start +size    - erase FLASH from addr 'start' to addr 'start + size', rounded up to sector size
erase N:SF[-SL]
    - erase sectors SF-SL in FLASH bank # N
erase bank N
    - erase FLASH bank # N
erase all
    - erase all FLASH banks
protect
protect - enable or disable FLASH write protection
on  start end
    - protect FLASH from addr 'start' to addr 'end'
protect on  N:SF[-SL]
    - protect sectors SF-SL in FLASH bank # N
protect on  bank N
    - protect FLASH bank # N
protect on  all
    - protect all FLASH banks
protect off start end
    - make FLASH from addr 'start' to addr 'end' writable
protect off N:SF[-SL]
    - make sectors SF-SL writable in FLASH bank # N
protect off bank N
    - make FLASH bank # N writable
protect off all
    - make all FLASH banks writable
w83l786g: i2c_read failed regaddr = 0x%x
VCORE =%d.%03d V
VRAM =%d.%03d V
Vcc =%d.%03d V
Vin1-Singal core CPU voltage =%d.%03d V
Vin2-Dual core,or 700MHz =%d.%03d V
invalid gpio number
w83l786g_test regaddr = 0x%x
value = %x
%d%s
-%d%s
-0.5
Temprature1: %s
Temprature2: %s
Read GPIO %d = %x .
pca9535: i2c_write failed
w83l786g: i2c_write failed regaddr = 0x%x
w83l786g_gpio_1_5_output_mode_control emtry
w83l786g_gpio_1_7_output_default emtry
Invalid value.
Set GPIO %d=%d .
w83l786g_gpio_io_def emtry
w83l786g_gpio_mode_setting emtry
pca9535: i2c_read failed
./gpioexpctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
Read expanded GPIO %u : %u 
./gpioexpctrl <set> <gpio pin number> <0/1>
Write expanded GPIO %u : %u 
invalid setting vlaue
Error reading the chip.
Error writing the chip.
Valid chip addresses:
 %02X
%04x:
 %02x
    
CRC32 for %08lx ... %08lx ==> 
Error reading the chip,
%08lx:
Error reading the chip,
 %02lx
 %04lx
 %08lx
gpioexpctrl
gpioexpctrl   - control expanded gpio 
	 Control expanded GPIO. 
	 gpioexpctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
gettemp
gettemp   - get the temparature of board
gettemp
getvoltage
getvoltage   - get the CPU voltage of board
getvoltage
imd     - i2c memory display
chip address[.0, .1, .2] [# of objects]
    - i2c memory display
imm     - i2c memory modify (auto-incrementing)
chip address[.0, .1, .2]
    - memory modify, auto increment address
inm     - memory modify (constant address)
chip address[.0, .1, .2]
    - memory modify, read and keep address
imw     - memory write (fill)
chip address[.0, .1, .2] value [count]
    - memory write (fill)
icrc32
icrc32  - checksum calculation
chip address[.0, .1, .2] count
    - compute CRC32 checksum
iprobe
iprobe  - probe to discover valid I2C chip addresses
    -discover valid I2C chip addresses
iloop
iloop   - infinite loop on address range
chip address[.0, .1, .2] [# of objects]
    - loop, reading a set of addresses
ERROR: Unsupported DMA mode: %d
ERROR: Unable to register IDE device, IDE descriptor list full!
IDE read: device %d not idle
cvmx_ptr_to_phys() passed a NULL pointer
ERROR: timeout waiting for DMA completion
IDE read: device %d not ready
Error on write (no IRQ) dev %d blk %ld: status 0x%02x
Error on read (no IRQ) dev %d blk %ld: status 0x%02x
Start IDE I/O test 
Test failed on block %d
Test done
  ide %d: 
Setting DMA mode for device
 Bus %d (CF Card): 
 Bus %d (IDE)    : 
 Bus %d (SATA)   : OK
** Timeout **
not available  
Reset IDE: 
IDE device %d: 
no IDE devices available
IDE device %d: 
part
unknown device
... is now current device
IDE device %d not available
IDE read: device %d block # %qd, count %ld ... 
%ld blocks read: %s
IDE write: device %d block # %qd, count %ld ... 
%ld blocks written: %s
ERROR
ide     - IDE sub-system
reset - reset IDE controller
ide info  - show available IDE devices
ide device [dev] - show or set current device
ide part [dev] - print partition table of one or all IDE devices
ide read  addr blk# cnt
ide write addr blk# cnt - read/write `cnt' blocks starting at block `blk#'
    to/from memory address `addr'
ide_test
ide_test  - test CF write
Unknown operator '%s'
Invalid data width specifier
itest
itest	 - return true/false on integer compare
[.b, .w, .l, .s] [*]value1 <op> [*]value2
download_baudrate
## Switching baudrate to %d bps for kermit download...
## Ready for binary (kermit) download to 0x%08lX at %d bps...
## Total Size      = 0x%08x = %d Bytes
0x%X
## Binary (kermit) download aborted
## Start Addr      = 0x%08lX
## Switching to baudrate to %d bps....
loadb
loadb   - load binary file over serial line (kermit mode)
[ off ] [ baud ]
    - load binary file over serial line with offset 'off' and baudrate 'baud'
 sets environment variables filesize, load_addr
 If offset is 0, then file will be loaded to the default load address
Error freeing block: %s
Base Address64: 0x%16qx, 
Base Address: 0x%08lx
writing 0x%x to addr: 0x%llx
writing 0x%llx to addr: 0x%llx
attempting to read from addr: 0x%llx
0x%llx: 0x%x
0x%llx: 0x%llx
named_block_addr
named_block_size
Named allocation failed!
Allocated 0x%llx bytes at address: 0x%llx, name: %s
0x%llx
Looking for value other than 0x%x, addr: 0x%x
Found 0x%x at addr %p
MD5 for %08lx ... %08lx ==> %08llx%08llx
verify not supported
CRC32 for %08lx ... %08lx ==> %08lx
error : wrong pattern in 
baseAddress[offset]= %qx , offset %qx, octeon_read64(baseAddress)=%qx, pattern=%qx
baseAddress[offset]= %qx , offset %qx, octeon_read64(baseAddress)=%qx, antipattern=%qx
Testing memory ...
Testing first 128M memory :
Testing from %qx to %qx.
Data bus test error!
Data bus test passed.
Address bus test error!
Address bus test passed.
Device test error!
Device test passed.
All memory test passed.
Zero length ???
Copy to Flash... 
word at 0x%08lx (0x%08lx) != word at 0x%08lx (0x%08lx)
word
halfword at 0x%08lx (0x%04x) != halfword at 0x%08lx (0x%04x)
byte at 0x%08lx (0x%02x) != byte at 0x%08lx (0x%02x)
byte
halfword
Total of %ld %s%s were the same
 %08x
 %04x
Lower 256Mb
Middle 256Mb
Upper 15.5Gb
md      - memory display
[.b, .w, .l] address [# of objects]
    - memory display
mm      - memory modify (auto-incrementing)
[.b, .w, .l] address
    - memory modify, auto increment address
nm      - memory modify (constant address)
[.b, .w, .l] address
    - memory modify, read and keep address
mw      - memory write (fill)
[.b, .w, .l] address value [count]
    - write memory
cp      - memory copy
[.b, .w, .l] source target count
    - copy memory
cmp     - memory compare
[.b, .w, .l] addr1 addr2 count
    - compare memory
crc32
crc32   - checksum calculation
address count [addr]
    - compute CRC32 checksum [save at addr]
md5   - MD5 hash calculation
address count [addr]
    - compute MD5 [save at addr]
base
base    - print or set address offset
    - print address offset for memory commands
base off
    - set address offset for memory commands to 'off'
read64
read64    - read 64 bit word from 64 bit address
    - read 64 bit word from 64 bit address
read64 addr
    - read 64 bit word from 64 bit address
write64
write64    - write 64 bit word to 64 bit address
    - write 64 bit word to 64 bit address
write64 addr val
    - write 64 bit word to 64 bit address
namedalloc
namedalloc    - Allocate a named bootmem block
    - Allocate a named bootmem block
namedalloc name size [address]
    - Allocate a named bootmem block with a given name and size at an
      optional fixed address.  Sets environment variables named_block_addr,
      named_block_size to address and size of block allocated.
namedfree
namedfree    - Free a named bootmem block
    - Free a named bootmem block
namedfree name
    - Free a named bootmem block.
namedprint
namedprint    - Print list of named bootmem blocks
    - Print list of named bootmem blocks
namedprint
    - Print list of named bootmem blocks.
freeprint
freeprint    - Print list of free bootmem blocks
    - Print list of free bootmem blocks
freeprint
    - Print list of free bootmem blocks.
read64b
read64b    - read 8 bit word from 64 bit address
    - read 8 bit word from 64 bit address 
read64b addr
    - read 8 bit word from 64 bit address
read64s
read64s    - read 16 bit word from 64 bit address
    - read 16 bit word from 64 bit address 
read64s addr
    - read 16 bit word from 64 bit address
read64l
read64l    - read 32 bit word from 64 bit address
    - read 32 bit word from 64 bit address 
read64l addr
    - read 32 bit word from 64 bit address
write64b
write64b    - write 8 bit word to 64 bit address
    - write 8 bit word to 64 bit address
write64b addr val
    - write 8 bit word to 64 bit address
write64s
write64s    - write 16 bit word to 64 bit address
    - write 16 bit word to 64 bit address
write64s addr val
    - write 16 bit word to 64 bit address
write64l
write64l    - write 32 bit word to 64 bit address
    - write 32 bit word to 64 bit address
write64l addr val
    - write 32 bit word to 64 bit address
read_cmp
read_cmp    - read and compare memory to val
    - read and compare memory to val
read_cmp addr val
    - read and compare memory to val
loop
loop    - infinite loop on address range
[.b, .w, .l] address number_of_objects
    - loop on a set of addresses
mtest
mtest   - simple RAM test
[start [end [pattern]]]
    - simple RAM read/write test
[%x] 
%u.     (%04hx)                 -- %s --
  (%04hx:%04hx) %u.
1000
%2u,%2u =   b%u%u    speed selection = %s Mbps
half
full
%2u    = %5u    duplex = %s
IEEE 802.3
IEEE 802.9 ISLAN-16T
%2u-%2u = %5u    selector = %s
%2u-%2u =     %u    selector = %s
%2u   
%2u-%2u
 = %5u    %s
PHY 0x%02X: OUI = 0x%04X, Model = 0x%02X, Rev = 0x%02X, %3dbaseT, %s
Error reading from the PHY addr=%02x reg=%02x
addr=%02x reg=%02x data=
%04X
Error writing to the PHY addr=%02x reg=%02x
The MII dump command only formats the standard MII registers, 0-5.
PHY control register
PHY status register
PHY ID 1 register
PHY ID 2 register
Autonegotiation advertisement register
Autonegotiation partner abilities register
loopback
speed selection
A/N enable
power-down
isolate
restart A/N
duplex
collision test enable
(reserved)
100BASE-T4 able
100BASE-X  full duplex able
100BASE-X  half duplex able
10 Mbps    full duplex able
10 Mbps    half duplex able
100BASE-T2 full duplex able
100BASE-T2 half duplex able
extended status
MF preamble suppression
A/N complete
remote fault
A/N able
link status
jabber detect
extended capabilities
OUI portion
manufacturer part number
manufacturer rev. number
next page able
reserved
asymmetric pause
pause enable
100BASE-TX full duplex able
100BASE-TX able
10BASE-T   full duplex able
10BASE-T   able
xxx to do
acknowledge
asymmetric pause able
pause able
100BASE-X full duplex able
10BASE-T full duplex able
10BASE-T able
mii     - MII utility commands
info  <addr>                  - display MII PHY info
mii read  <addr> <reg>        - read  MII PHY <addr> register <reg>
mii write <addr> <reg> <data> - write MII PHY <addr> register <reg>
mii dump  <addr> <reg>        - pretty-print <addr> <reg> (0-5 only)
Addr and/or reg may be ranges, e.g. 2-7.
Note: Bit 7 of <addr> selects which MDIO bus to use
dx106
dx106     - DX106 utility commands
read  <reg>        - read  DX106 register <reg>
dx106 write <reg> <data> - write DX106 register <reg> data <data>
e1240
88e1240     - 88E1240 utility commands
read        - read  88E1240 register 
88e1240 write <phy id> <page> <reg> <data> <mask>- write 88E1240 phy id <phy id> page <page> register <reg> data <data> mask <mask>
system_red
system_green
usb_green
rs232_green
vpn_green
wlan_green
security
rs232
wlan
system_red_blink
system_yellow_blink
system_green_blink
security_yellow_blink
security_red_blink
usb_green_blink
rs232_green_blink
vpn_green_blink
wlan_green_blink
SPI interface is not initialed
spanson flash S25FL016A
32 sectors with 512Kb each
spanson flash S25FL032P
64 sectors with 512Kb each
Eon flash EN25F16
Atmel flash AT45DB161D
4096 Pages with 512byte each
device id = 0x%08x
command failed
read %d byte from 0x00%02lx%02lx%02lx
value 0x%02lx 0x%02lx 0x%02lx 0x%02lx 0x%02lx 0x%02lx 0x%02lx 0x%02lx 0x%02lx
erase sector %d sector %x
erase sector %x
command error!!!
Detect Reset button
 Success
 Fail
cgpio [port num]
Clr GPIO %d .
ledtest off <security/usb/rs232/vpn/cf/voip/pci/wlan/lan/wan>
ledtest on [system_red|system_green|system_yellow|security_red|security_yellow|usb_green|rs232_green|vpn_green|cf|voip|pci|wlan_green|lan_green|lan_yellow|wan_green|wan_yellow]
Turn off security led.
Turn off usb led.
Turn off rs232 led.
Turn off vpn led.
Turn off wlan led.
system
Turn off sys led.
e1240 write 0x4 0x3 0x10 0x0080 0x00F0
Turn off cf led.
voip
e1240 write 0x6 0x3 0x10 0x0080 0x00F0
Turn off voip led.
e1240 write 0x7 0x3 0x10 0x0080 0x00F0
Turn off pci led.
e1240 write 0x4 0x3 0x10 0x8808 0xFF0F
e1240 write 0x5 0x3 0x10 0x8808 0xFF0F
e1240 write 0x6 0x3 0x10 0x8808 0xFF0F
e1240 write 0x7 0x3 0x10 0x8808 0xFF0F
Turn off lan led.
mii write 0xC 0x19 0x0002
mii write 0xD 0x19 0x0002
Turn off wan led.
e1240 write 0x4 0x3 0x10 0x0000 0xFFFF
e1240 write 0x5 0x3 0x10 0x0000 0xFFFF
e1240 write 0x6 0x3 0x10 0x0000 0xFFFF
e1240 write 0x7 0x3 0x10 0x0000 0xFFFF
Turn off all leds.
Invalid Parameter!
ledtest off [system|security|usb|rs232|vpn|cf|voip|pci|wlan|lan|wan]
Turn on system red led.
Turn on system green led.
system_yellow
Turn on system yellow led.
security_red
Turn on security_red led.
security_yellow
Turn on security_yellow led.
Turn on usb green led.
Turn on rs232 green led.
Turn on vpn green led.
e1240 write 0x4 0x3 0x10 0x0090 0x00F0
Turn on cf led.
e1240 write 0x6 0x3 0x10 0x0090 0x00F0
Turn on voip led.
e1240 write 0x7 0x3 0x10 0x0090 0x00F0
Turn on pci led.
Turn on wlan green led.
lan_green
e1240 write 0x4 0x3 0x10 0x9809 0xFF0F
e1240 write 0x5 0x3 0x10 0x9809 0xFF0F
e1240 write 0x6 0x3 0x10 0x9809 0xFF0F
e1240 write 0x7 0x3 0x10 0x9809 0xFF0F
Turn on lan green led.
lan_yellow
e1240 write 0x4 0x3 0x10 0x0908 0x0F0F
e1240 write 0x5 0x3 0x10 0x0908 0x0F0F
e1240 write 0x6 0x3 0x10 0x0908 0x0F0F
e1240 write 0x7 0x3 0x10 0x0908 0x0F0F
Turn on lan yellow led.
wan_green
mii write 0xC 0x19 0x0233
mii write 0xD 0x19 0x0233
Turn on wan green led.
wan_yellow
mii write 0xC 0x19 0x0322
mii write 0xD 0x19 0x0322
Turn on wan yellow led.
e1240 write 0x4 0x3 0x10 0x9899 0xFFFF
e1240 write 0x5 0x3 0x10 0x9899 0xFFFF
e1240 write 0x6 0x3 0x10 0x9899 0xFFFF
e1240 write 0x7 0x3 0x10 0x9899 0xFFFF
Turn on all leds.
ledtest on [system_red|system_green|system_yellow|security_red|security_yellow|usb_green 
	 |rs232_green|vpn_green|cf|voip|pci|wlan_green|lan_green|lan_yellow|wan_green|wan_yellow]
wrong parameter!
ledtest off [security|usb|rs232|vpn|cf|voip|pci|wlan|lan|wan]
rgpio [port num]
Set GPIO %d .
./gpioctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
invalid pin number
Read GPIO %u : %u 
./gpioctrl <set> <gpio pin number> <0/1>
Write GPIO %u : %u 
Read GPIO %d = %d .
sleep
sleep   - delay execution for some time
    - delay execution for N seconds (N is _decimal_ !!!)
gpioctrl
gpioctrl   - control gpio 
	 Control GPIO. 
	 gpioctrl <get <gpio pin number> | set <gpio pin number> <0/1>>
ledtest
	 ledtest on [system_red|system_green|system_yellow|security_red|security_yellow|usb_green 
	 |rs232_green|vpn_green|cf|voip|pci|wlan_green|lan_green|lan_yellow|wan_green|wan_yellow]
	 ledtest off [security|usb|rs232|vpn|cf|voip|pci|wlan|lan|wan]
frtest
frtest   - Test reset button.
	 Press reset button then execute command.
spireaddeviceid
spireaddeviceid
spierase
spierase
spieraseall
spieraseall
spiread
spiread
spiwritefile
spiwritefile
spiinit
spiinit
spiinfo
spiinfo
No memory for page buffer
Error (%d) reading page %08lx
Page %08lx dump:
	%02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x
OOB:
	%02x %02x %02x %02x %02x %02x %02x %02x
device %d 
whole chip
offset 0x%lx, size 0x%x
'%s' is not a number
quiet
init
wait...
no_vnand
******* WARNING: VNAND mechanism is turned OFF. Use with caution. *******
info
Device %d: %s, sector size %u KiB
device
no devices available
Device %d: %s
No such device
Device %d: %s
dump
scrub
markbad
biterr
lock
unlock
Device %d bad blocks:
  %08lx
clean
NAND %s: 
Warning: scrub option will erase all factory set bad blocks!
         There is no reliable way to recover them.
         Use this command only for testing purposes if you
         are sure of what you are doing!
Really scrub this NAND flash? <y/N>
scrub aborted
.oob
.jffs2
Unknown nand command suffix '%s'.
written
 %d bytes %s: %s
block 0x%08lx successfully marked as bad
block 0x%08lx NOT marked as bad! ERROR %d
tight
status
nand
nand    - NAND sub-system
info - show available NAND devices
nand device [dev] - show or set current device
nand read - addr off|partition size
nand write - addr off|partition size
    read/write 'size' bytes starting at offset 'off'
    to/from memory address 'addr', skipping bad blocks.
nand erase [clean] [off size] - erase 'size' bytes from
    offset 'off' (entire device if not specified)
nand bad - show bad blocks
nand dump[.oob] off - dump page
nand scrub - really clean NAND erasing bad blocks (UNSAFE)
nand markbad off - mark bad block at offset (UNSAFE)
nand biterr off - make a bit error at offset (UNSAFE)
nand lock [tight] [status]
    bring nand to lock state or display locked pages
nand unlock [offset] [size] - unlock section
ping failed; host %s is not alive
host %s is alive
gatewayip
netmask
hostname
rootpath
ipaddr
serverip
dnsip
domain
bootp
bootp   - boot image via network using BootP/TFTP protocol
[loadAddress] [bootfilename]
tftpboot
tftpboot- boot image via network using TFTP protocol
[loadAddress] [bootfilename]
If loadAddress is 0, then file will be loaded to the default load address
dhcp
dhcp    - invoke DHCP client to obtain IP/boot params
ping
ping    - send ICMP ECHO_REQUEST to network host
pingAddress
Saving Environment to %s...
loadaddr
loadaddr not set due to load reserved memory allocated at 0x%x.
Please refer to the bootloader SDK documentation.
ERROR: Invalid parameter
stdout
stderr
Can't delete "%s"
baudrate
## Baudrate %d bps not supported
## Switch baudrate to %d bps and press ENTER ...
addr
console_uart
## Error: environment overflow, "%s" deleted
ethaddr
bootfile
stdin
Please enter '%s':
setenv
 ** Abort
Environment size: %d/%d bytes
## Error: "%s" not defined
printenv
printenv- print environment variables
    - print values of all environment variables
printenv name ...
    - print value of environment variable 'name'
setenv  - set environment variables
name value ...
    - set environment variable 'name' to 'value ...'
setenv name
    - delete environment variable 'name'
saveenv
saveenv - save environment variables to persistent storage
askenv
askenv  - get environment variables from stdin
name [message] [size]
    - get environment variable 'name' from stdin (max 'size' chars)
askenv name
    - get environment variable 'name' from stdin
askenv name size
    - get environment variable 'name' from stdin (max 'size' chars)
askenv name [message] size
    - display 'message' string and get environment variable 'name'from stdin (max 'size' chars)
run     - run commands in an environment variable
var [...]
    - run the commands in the environment variable(s) 'var'
Mass storage controller
Build before PCI Rev2.0
Network controller
Display controller
Multimedia device
Memory controller
Bridge device
Simple comm. controller
Base system peripheral
Input device
Docking station
Processor
Serial bus controller
Intelligent controller
Satellite controller
Cryptographic device
Does not fit any class
  vendor ID =                   0x%.4x
  device ID =                   0x%.4x
  command register =            0x%.4x
  status register =             0x%.4x
  revision ID =                 0x%.2x
  class code =                  0x%.2x (%s)
  sub class code =              0x%.2x
  programming interface =       0x%.2x
  cache line =                  0x%.2x
  latency time =                0x%.2x
  header type =                 0x%.2x
  BIST =                        0x%.2x
  base address 0 =              0x%.8x
  base address 1 =              0x%.8x
  base address 2 =              0x%.8x
  base address 3 =              0x%.8x
  base address 4 =              0x%.8x
  base address 5 =              0x%.8x
  cardBus CIS pointer =         0x%.8x
  sub system vendor ID =        0x%.4x
  sub system ID =               0x%.4x
  expansion ROM base address =  0x%.8x
  interrupt line =              0x%.2x
  interrupt pin =               0x%.2x
  min Grant =                   0x%.2x
  max Latency =                 0x%.2x
  primary bus number =          0x%.2x
  secondary bus number =        0x%.2x
  subordinate bus number =      0x%.2x
  secondary latency timer =     0x%.2x
  IO base =                     0x%.2x
  IO limit =                    0x%.2x
  secondary status =            0x%.4x
  memory base =                 0x%.4x
  memory limit =                0x%.4x
  prefetch memory base =        0x%.4x
  prefetch memory limit =       0x%.4x
  prefetch memory base upper =  0x%.8x
  prefetch memory limit upper = 0x%.8x
  IO base upper 16 bits =       0x%.4x
  IO limit upper 16 bits =      0x%.4x
  bridge control =              0x%.4x
  capabilities =                0x%.2x
  CardBus number =              0x%.2x
  CardBus latency timer =       0x%.2x
  CardBus memory base 0 =       0x%.8x
  CardBus memory limit 0 =      0x%.8x
  CardBus memory base 1 =       0x%.8x
  CardBus memory limit 1 =      0x%.8x
  CardBus IO base 0 =           0x%.4x
  CardBus IO base high 0 =      0x%.4x
  CardBus IO limit 0 =          0x%.4x
  CardBus IO limit high 0 =     0x%.4x
  CardBus IO base 1 =           0x%.4x
  CardBus IO base high 1 =      0x%.4x
  CardBus IO limit 1 =          0x%.4x
  CardBus IO limit high 1 =     0x%.4x
  subvendor ID =                0x%.4x
  subdevice ID =                0x%.4x
  PC Card 16bit base address =  0x%.8x
unknown header
0x%.4x     0x%.4x     %-23s 0x%.2x
Scanning PCI devices on bus %d
BusDevFun  VendorId   DeviceId   Device Class       Sub-Class
_____________________________________________________________
%02x.%02x.%02x   
Found PCI device %02x.%02x.%02x:
pci     - list and access PCI Configuraton Space
[bus] [long]
    - short or long list of PCI devices on bus 'bus'
pci header b.d.f
    - show header of PCI device 'bus.device.function'
pci display[.b, .w, .l] b.d.f [address] [# of objects]
    - display PCI configuration space (CFG)
pci next[.b, .w, .l] b.d.f address
    - modify, read and keep CFG address
pci modify[.b, .w, .l] b.d.f address
    -  modify, auto increment CFG address
pci write[.b, .w, .l] b.d.f address value
    - write to CFG address
Restoring SofawWare image ...
ERROR: failed load %s image.
ERROR: failed to restore %s image.
Preset configuration file does not exist 
does not 
Preset configuration file %sexist.
ERROR: failed to reset BLOB.
BLOB was reset successfully.
ERROR: failed to update BLOB.
BLOB was updated successfully.
ERROR: failed to load %s image 
ERROR: failed run SofaWare image
Reset 2 default ...
ERROR: failed to reset variables.
ERROR: failed to reset SofaWare settings.
ERROR: failed to reset Cloud Storage firmware
Restoring primary DSL-firmware ...
ERROR: failed to restore DSL-firmware
ERROR: No firmware to install. 
ERROR: Failed to install %s firmware.
%s firmware installed successfully.
ERROR: Failed to start image
ERROR: Failed to run bin2go image.
ERROR: Failed to update bootcode.
Bootcode was updated successfully.
ERROR: Failed to run bootcode.
ERROR: Unrecognized image type.
ERROR: fail to load file
tftp_filename
Got .firm file.
Got SofaWare image file.
Got boot loader script.
Got preset configuration file.
Got unrecognized file ("%s"). 
sw_tftp_any_file
Writting file "%s" ...
ERROR: Corrupted image, skip it (name: "%s")
firmware0
firmware1
dsl0
dsl1
dsl0-b
dsl1-b
blob_adsl_annex
DSL firmware's Annex (%x) differ from mine (%x). Skip.
Error: SWFS bad dsl firmware!
Error: Upgrade dsl failed
ERROR: unrecognized SWFS firmware name: "%s"
Error: Can not get annex from filename ('%s')
sofaware_tftpload
sofaware_tftpload - load image via network using TFTP protocol
sofaware_restore_image
sofaware_restore_image - restore SofaWare primary firmware from secondary firmware
sofaware_reset2def
sofaware_reset2def - reset 2 defaults
sofaware_start
sofaware_start - SofaWare start
sofaware_blob_update
sofaware_blob_update - SofaWare BLOB update
sofaware_blob_reset
sofaware_blob_reset - SofaWare BLOB reset
sofaware_show_info
sofaware_show_info - Print SofaWare information 
sofaware_preset_cfg_reset
sofaware_preset_cfg_reset - Reset SofaWare preset configuration file 
ERROR clearing memory using TLB mappings!
TLB addr: %p
TLB[%02d] page0: 0x%llx
TLB[%02d] page1: 0x%llx
TLB[%02d] pagesize:      0x%08x (%d)
TLB[%02d] virt : 0x%llx - 0x%llx
octeon_load_app_hi
ERROR: TLB overlap - out of virtual memory in 0x10000000 - 0x20000000 range
Bootloader error: out of memory.
ERROR: heap too small: 0x%x, must be at least 0x%x bytes for temp boot descriptor storage
Pointer not to ELF data!
Data isn't an ELF32 or ELF64 file!
Data isn't in big-endian mode.
Data isn't an executable!
Data isn't an executable for a MIPS R3000 or R4000!
.shstrtab
.cvmx_shared_hw
Error: cvmx_shared_hw is no longer supported.
.cvmx_shared
ERROR CREATING TLB MAPPING (read only)
ERROR CREATING TLB MAPPING (CVMX_SHARED)
no_mark_private_data
ERROR CREATING TLB MAPPING (rw)
ERROR CREATING TLB MAPPING for stack/heap
NOTICE: oversize TLB mappings for application used, application can't use 1-1 TLB mappings.
ERROR setting up boot descriptor block, core_mask: 0x%llx
ERROR setting boot vectors, core_mask: 0x%llx
Bootloader: Done loading app on coremask: 0x%x
ERROR: unable to find section header string table, aborting
stack=
heap=
debug
setting debug flag!
break
setting break flag!
coremask=0x
coremask=
forceboot
numcores=
skipcores=
endbootargs
Coremask is empty after coremask_override mask. Nothing to do.
Invalid coremask.
ERROR: Can't load code on core twice! (provided coremask(0x%x) overlaps previously loaded coremask(0x%x))
Bootloader: Booting Octeon Executive application at 0x%08lx, core mask: 0x%x, stack size: 0x%x, heap size: 0x%x
ERROR: Unable to properly load application
bootoct
bootoct - Boot from an Octeon Executive ELF image in memory
 [elf_address [stack=stack_size] [heap=heap_size] [coremask=mask_to_run | numcores=core_cnt_to_run] [forceboot] [debug] [break] [endbootargs] [app_args ...] .
elf_address - address of ELF image to load. defaults to $(loadaddr). If 0, default load address used.
stack       - size of stack in bytes.  Defaults to 1 megabyte
heap        - size of heap in bytes.  Defaults to 3 megabytes
coremask    - mask of cores to run on.  Anded with coremask_override environment
              variable to ensure only working cores are used
numcores    - number of cores to run on.  Runs on specified number of cores, taking into
              account the coremask_override.
skipcores   - only meaningful with numcores.  Skips this many cores (starting from 0) when
              loading the numcores cores. For example, setting skipcores to 1 will skip core 0
              and load the application starting at the next available core.
debug       - if present, bootloader passes debug flag to application which will cause
              the application to stop at a breakpoint on startup
break       - if present, exit program when control-c is received on the console
forceboot   - if set, boots application even if core 0 is not in mask
endbootargs - if set, bootloader does not process any further arguments and only passes
              the arguments that follow to the application.  If not set, the application
              gets the entire commnad line as arguments.
Warning: No memory size provided, this application won't co-exist with simple exec. applications or Linux.
Warning: Coremask has %d cores set.  Application must support multiple cores for proper operation.
Allocating memory for ELF: Base addr, 0x%x, size: 0x%x
Error allocating memory for ELF image!
ERROR: only loading of 32 bit  ELF images is supported
## ERROR loading File!
## Loading ELF image with entry point: 0x%08lx ...
pci_console_active
icache_prefetch_disable
argv[%d]: %s
__tmp_reserved_linux
Skipping non LOAD program header (type 0x%x)
Error allocating memory for elf image!
Allocated memory for ELF segment: addr: 0x%x, size 0x%x
Attempting to allocate memory for ELF segment: addr: 0x%llx (adjusted to: 0x%llx), size 0x%x
Allocated memory for ELF segment: addr: 0x%llx, size 0x%x
## Loading Linux kernel with entry point: 0x%08qx ...
bootoctlinux
bootoctlinux - Boot from a linux ELF image in memory
elf_address [coremask=mask_to_run | numcores=core_cnt_to_run] [forceboot] [skipcores=core_cnt_to_skip] [endbootargs] [app_args ...]
elf_address - address of ELF image to load. If 0, default load address is used.
coremask    - mask of cores to run on.  Anded with coremask_override environment
              variable to ensure only working cores are used
numcores    - number of cores to run on.  Runs on specified number of cores, taking into
              account the coremask_override.
skipcores   - only meaningful with numcores.  Skips this many cores (starting from 0) when
              loading the numcores cores. For example, setting skipcores to 1 will skip core 0
              and load the application starting at the next available core.
forceboot   - if set, boots application even if core 0 is not in mask
endbootargs - if set, bootloader does not process any further arguments and only passes
              the arguments that follow to the kernel.  If not set, the kernel
              gets the entire commnad line as arguments.
bootoctelf
bootoctelf - Boot a generic ELF image in memory. NOTE: This command does not support
             simple executive applications, use bootoct for those.
elf_address [mem_size [coremask=mask_to_run | numcores=core_cnt_to_run] [skipcores=core_cnt_to_skip] [forceboot] ]
elf_address - address of ELF image to load. If 0, default load address is used.
mem_size    - amount of memory to reserve for ELF file.  Starts at ELF entry point rounded down to 1 MByte alignment.
              No memory allocated if not specified.  (Program will not coexist with simple executive
              applications or Linux if memory is not allocated properly.
coremask    - mask of cores to run on.  Anded with coremask_override environment
              variable to ensure only working cores are used.  Note: Most ELF files
              are only suitable for booting on a single core.
forceboot   - if set, boots application even if core 0 is not in mask
numcores    - number of cores to run on.  Runs on specified number of cores, taking into
              account the coremask_override.
skipcores   - only meaningful with numcores.  Skips this many cores (starting from 0) when
              loading the numcores cores. For example, setting skipcores to 1 will skip core 0
              and load the application starting at the next available core.
Sbox4_cm# 
- No help available.
Unknown command '%s' - try 'help' without arguments for list of all known commands
version
version - print monitor version
echo
echo    - echo args to console
[args..]
    - echo args to console; \c suppresses newline
help    - print online help
[command ...]
    - show help information (for 'command')
'help' prints online help for the monitor commands.
Without arguments, it prints a short usage message for all commands.
To get detailed help information for specific commands you can type
'help' with one or more command names as arguments.
?       - alias for 'help'
Cannot initialize the list of devices!
serial
*** Warning - bad CRC, using default environment
Using default environment
Flash
Timeout writing to Flash
Flash not Erased
Can't write to protected Flash sectors
Outside available Flash
Start and/or end address not on sector boundary
Unknown Vendor of Flash
Unknown Type of Flash
General Flash Programming Error
%s[%d] FIXME: rc=%d
flash.c
PHY 1000BT Status read failed
PHY duplex read failed, assuming half duplex
PHY speed1 read failed, assuming 10bT
PHY reset timed out
** No boot file defined **
** Block device %s %d not supported
** Bad partition %d **
U-Boot
** Invalid partition type "%.32s" (expect "U-Boot")
** Bad partition - %s %d:%d **
** Bad ext2 partition or disk - %s %d:%d **
** Error ext2fs_ls() **
ext2ls
ext2ls  - list files in a directory (default /)
ext2load
ext2load- load binary file from a Ext2 filesystem
<interface> <dev[:part]> [addr] [filename] [bytes]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from ext2 filesystem
      If addr is 0, then file will be loaded to the default load address
VCore Voltage: %d.%03dV (CR20=%d)
VRAM Voltage: %d.%03dV (CR21=%d)
VIN#1(1P2V) Voltage: %d.%03dV (CR23=%d)
VIN#2(2P5V) Voltage: %d.%03dV (CR24=%d)
VTIN#1 Temperature: %d.%02d'C (CR26=%d, CR94=%d)
VTIN#2 Temperature: %d.%02d'C (CR27=%d, CR95=%d)
hwm     - get hardware voltage/temperature status
 - without arguments: print hardware voltage/temperature status
gpio#%d = %d
gpio
gpio    - get/set gpio
gpio <pin#> [0|1] 
** Too many args (max. %d) **
Unknown command '%s' - try 'help'
## Command too long!
sw_tftpsrvmode
RST %d
bootdelay
bootcmd
%2d 
<INTERRUPT>
unknown
FATAL ERROR!!! Switch reset has failed!
PAL rev: %d.%02d, MCU rev: %d.%02d, CPU voltage: %d.%02d
%d 0.%.2d 
%d 1.%.2d 
Boot    
Re-booting ...
*** reset failed ***
sw_serial_console
external
[DEBUG STUB]Output too long: %d
!Core XX 
taking focus.
!Core is not in the exception handler. Focus not changed.
!Focus core was added to the masked.
[DEBUG STUB]Query #%d is not valid
[DEBUG STUB]Register #%d is not valid
[DEBUG STUB]Unknown debug command: %s
ERROR: miiphy_read_wrapper(0x%x, 0x%x) timed out.
cvmx_phys_to_ptr() passed a zero address
%s: 
Down 
%d Mbps 
Full duplex 
Half duplex 
(port %2d)
%s_fpa_alloc_%d
__tmp
Unable to allocate %lu bytes for FPA pool %ld
ERROR allocating buffer for packet!
Failed to send the packet
%s called with tag switch in progress
WARNING: Tag switch is taking a long time, possible deadlock
Error packet received (code %d), dropping
disable_spi
SPI interface disabled with 'disable_spi' environment variable
Warning: Enabling FPA when FPA already enabled.
Neither interface is RGMII, unable to reset network HW
Error draining PKO: queue %d doorbell count: %d is not zero
ERROR: unable to reset packet input!
ERROR: TFTP network reset not supported on PASS 1
cvmx_cmd_queues
FATAL ERROR: Network shutdown failed.  Please reset the board.
disable_networking
Networking disabled with 'disable_networking' environment variable, skipping RGMII interface
No available MAC addresses for RGMII interface, skipping
octeth%d
WARNING:
WARNING:OCTEON pass 1 does not support network hardware reset.
WARNING:Bootloader networking use will cause unstable operation of any other
WARNING:program or OS using the network hardware.
PCI-X
PCI Status: %s %s-bit
PCI Status: %d MHz (measured %d-%d MHz)
PCI Status: SOFTWARE OVERRIDE to %s %d MHz
Starting PCI
PCI BAR 0: 0x%08lx, PCI BAR 1: Memory 0x%08lx  PCI 0x%08lx
### ERROR ### Please RESET the board ###
DRAM:  
ERROR: malloc heap exhausted!
IPD backpressure workaround verified, took %d loops
IPD backpressure workaround FAILED verfication. Adjust octeon_ipd_bp_enable() for this chip!
IPD backpressure workaround FAILED. Adjust octeon_ipd_bp_enable() for this chip!
PCIe: Aligning TLP counters (OUT_P_COUNT=%d)
PCIe: Soft reset after alignment
Clearing DRAM.....
 done
FATAL: Error initializing free memory list
__tmp_bootloader_internal
ERROR: Unable to allocate memory for heap.... (1)
octeon_reserved_mem_load_size
auto
octeon_reserved_mem_load_base
__tmp_load
ERROR: Unable to allocate bootloader reserved memory (addr: 0x%x, size: 0x%x).
0x%x
WARNING: No reserved memory for image loading.
octeon_reserved_mem_linux_size
octeon_reserved_mem_linux_base
ERROR: Unable to allocate linux reserved memory (addr: 0x%x, size: 0x%x).
Flash: 
Flash boot bus region not enabled, skipping NOR flash config
0x%04x
coremask_override
Warning: No chip capability tuple found in eeprom, coremask_override may be set incorrectly
numcores
Using PCI console, serial port disabled.
PCI CONS
%s board revision major:%d, minor:%d, serial #: %s
OCTEON %s revision: %d, Core clock: %d MHz, DDR clock: %d MHz (%d Mhz data rate)
WARNING: loadaddr not set, defaulting to %s.  Please either define a load reserved block or set the loadaddr environment variable.
env_addr
env_size
flash_base_addr
flash_size
uboot_flash_addr
uboot_flash_size
flash_unused_addr
flash_unused_size
Net:   
hanging, init func: %d
Error message from before serial ready: %s
*************************************
ERROR: U-boot memory usage overlaps fixed address reserved area!
U-boot base address: 0x%08x, reserved top: 0x%08x
*************************************
ddr_clock_hertz
Parameter found in environment. ddr_clock_hertz = %d
ddr_ref_hertz
Parameter found in environment. ddr_ref_hertz = %d
OCTEON %s, Core clock: %d MHz, DDR clock: %d MHz (%d Mhz data rate)
WARNING:
WARNING: Measured DDR clock mismatch! expected: %d MHz, measured: %d MHz, cpu clock: %d MHz
WARNING: Using measured clock for configuration.
WARNING:
Warning: Clock descriptor tuple not found in eeprom, using defaults
WARNING: memory configured for %d mhz clock.  
If this is not the actual memory clock
poor performance and memory instability may result.  
The memory speed must be specified in the board eeprom
Warning: Board descriptor tuple not found in eeprom, using defaults
*** failed ***
WARNING: Data loaded outside of the reserved load area, memory corruption may occur.
WARNING: Please refer to the bootloader memory map documentation for more information.
ERROR copying memory using TLB mappings, cur_len: %d !
autoload=n
dram_size_mbytes=%d
ERROR allocating stack for core: %d
ERROR: unable to allocate memory for argument data
ERROR allocating memory for boot descriptor block
ERROR allocating memory for cvmx bootinfo block
blob_mac
00:11:22:33:44:55
####################################################################################
### Warning: only %02d cores available, not running with requested number of cores ###
ERROR: Can't boot cores that don't exist! (available coremask: 0x%x)
Notice: coremask changed to 0x%x based on coremask_override of 0x%x
WARNING: You have changed the coremask_override and are running code on non-functional cores.
WARNING: The program may crash and/or produce unreliable results.
__bootloader_env
BIST FAILURE: %s, error bits: 0x%llx
BIST FAILURE: %s, error bits ((bist_val & mask) ^ expected): 0x%llx
PCI console already setup.
pci_console_count
pci_console_size
WARNING: PCI console init FAILED
PCI console init succeeded, %d consoles, %d bytes each
WARNING: L2D ECC errors detected!
WARNING: L2T ECC errors detected!
WARNING: DDR ECC errors detected!
BIST FAILURE: POW_BIST_STAT: 0x%08x
COP0_CVMMEMCTL_REG
COP0_ICACHEERR_REG
GMX0_BIST
GMX1_BIST
IPD_BIST_STATUS
KEY_BIST_REG
L2D_BST0
L2C_BST0
L2C_BST1
L2C_BST2
CIU_BIST
PKO_REG_BIST_RESULT
PIP_BIST_STATUS
RNM_BIST_STATUS
SPX0_BIST_STAT
SPX1_BIST_STAT
TIM_REG_BIST_RESULT
TRA_BIST_STATUS
MIO_BOOT_BIST_STAT
IOB_BIST_STATUS
DFA_BST0
DFA_BST1
FPA_BIST_STATUS
ZIP_CMD_BIST_RESULT
USBNX_BIST_STATUS(0)
AGL_GMX_BIST
MIXX_BIST(0)
NPEI_BIST_STATUS
RAD_REG_BIST_RESULT
PCSX0_BIST_STATUS_REG(0)
PCSX1_BIST_STATUS_REG(1)
BIST Errors found.
'1' bits above indicate unexpected BIST status.
BIST check passed.
NPI_BIST_STATUS
Reading simulated SPD %p
Unbuffered
Registered
non-ECC
DIMM %d: DDR2 %s, %s
  %s
ddr_verbose
ddr_prompt
ERROR: DDR Reference Clock not specified.
clkr: %2lu, en: %2d, clkf: %4lu, pll_MHz: %4lu, ddr_hertz: %8lu, error: %8d
clkr: %2lu, en: %2d, clkf: %4lu, pll_MHz: %4lu, ddr_hertz: %8lu, error: %8d <==
ERROR: Can not compute a legal DDR clock speed configuration.
ddr_sil_mode
Parameter found in environment. ddr_sil_mode = %d
Disabled
Enabled
DDR Interface %d: %s,  Mask 0x%x
DDR Interface %d: %s, Target DCLK: %d
Enabling DCLK PLL
DDR Interface %d: %s
Performing LMC1 DCLK Offsetting Sequence
Performing DRESET Initialization Sequence
BIST ERROR: 0x%llx
CSRD2E = 0x%x
CSRE2D = 0x%x
MWF    = 0x%x
MWD    = 0x%x
MWC    = 0x%x
MRF    = 0x%x
MRD    = 0x%x
Performing LMCX Initialization Sequence
Measured DDR clock %d
DDR clock misconfigured. Resetting...
Please enter value for %s DDR param(enter for default):
No value entered, using default value for parameter %s
Using value %s for parameter %s
Initializing DDR interface %d, DDR Clock %d, DDR Reference Clock %d
ERROR: No dimms specified in the dimm_config_table.
ERROR: Install DIMMs in pairs for 128-bit interface
ddr_safe
Parameter found in environment. ddr_safe = %d
ERROR: DIMM 0 not detected.
ddr_narrow
Parameter found in environment: ddr_narrow, forcing narrow ddr interface
Unsupported number of Col Bits: %d
Unsupported number of Row Bits: %d
ERROR: Unsupported Octeon model: 0x%x
NOTICE: Memory size reduced by half on 2 rank memory configs.
row bits: %d, col bits: %d, banks: %d, ranks: %d, dram width: %d, size: %d MB
+ECC
DRAM Interface width: %d bits %s
CAS Latency was not specified by SPD: %#04x
CL%d Minimum Clock Rate                        : %6d ps
WARNING!!!!!!: DDR Clock Rate (tCLK) exceeds DIMM specifications!!!!!!!!
Unsupported refresh rate: %#04x
DDR Clock Rate (tCLK)                         : %6d ps
CAS Latency                                   : %6d
Refresh Rate (tREFI)                          : %6d ns
Minimum Row Precharge Time (tRP)              : %6d ps
Minimum Row Active to Row Active delay (tRRD) : %6d ps
Minimum RAS to CAS delay (tRCD)               : %6d ps
Minimum Active to Precharge Time (tRAS)       : %6d ps
Write Recovery Time (tWR)                     : %6d ps
Internal write to read command delay (tWTR)   : %6d ps
Device Min Auto-refresh Active/Command (tRFC) : %6d ps
Unsupported number of banks %d. Must be 4 or 8.
Unsupported number of ranks: %d
Unsupported SDRAM Width, %d.  Must be 8 or 16.
ddr_board_delay
Overriding internal board delay (%d ps).
Parameter found in environment. ddr_board_delay = %d ps
Board delay                                   : %6d ps
Error!!!  Board delay was not specified!!!
ddr_tskw
Parameter found in environment. ddr_tskw = %d
ddr_silo_hc
Parameter found in environment. ddr_silo_hc = %d
ddr_silo_qc
Parameter found in environment. ddr_silo_qc = %d
ddr_dic
Parameter found in environment. ddr_dic = %d
ddr_qs_dic
Parameter found in environment. ddr_qs_dic = %d
ddr_odt_ena
Parameter found in environment. ddr_odt_ena = %d
ddr_odt_mask
Parameter found in environment. ddr_odt_mask = 0x%x
ddr_odt_mask1
Parameter found in environment. ddr_odt_mask1 = 0x%x
ddr_rodt_ctl
Parameter found in environment. ddr_rodt_ctl = 0x%x
ddr_2t
Parameter found in environment. ddr_2t = %d
ddr_burst8
Parameter found in environment. ddr_burst8 = %d
ddr_delay_clk
Parameter found in environment. ddr_delay_clk = %d
ddr_delay_cmd
Parameter found in environment. ddr_delay_cmd = %d
ddr_delay_dq
Parameter found in environment. ddr_delay_dq = %d
delay_clk                                     : %6d
delay_cmd                                     : %6d
delay_dq                                      : %6d
sil_mode                                      : %6d
DDR Fixed Reference Clock Hertz               : %8d
clkf                                          : %6d
clkr                                          : %6d
EN2                                           : %6d
EN4                                           : %6d
EN6                                           : %6d
EN8                                           : %6d
EN12                                          : %6d
EN16                                          : %6d
LMC PLL Frequency                             : %6d MHz
Calculated DClk Frequency                     : %8d Hz
DDR PMOS dat                                  : %6d
DDR NMOS dat                                  : %6d
bunk_enable                                   : %6d
burst8                                        : %6d
ddr2t                                         : %6d
tskw                                          : %6d
silo_hc                                       : %6d
silo_qc                                       : %6d
sil_lat                                       : %6d
r2r_slot                                      : %6d
odt_ena                                       : %6d
qs_dic                                        : %6d
dic                                           : %6d
ctl_odt_mask                                  : %08x
ctl_odt_mask1                                 : %08x
ctl_rodt_ctl                                  : %08x
ddr_rodt_ena
Parameter found in environment. ddr_rodt_ena = %d
RODT enable                                   : %6d
RODT pctl                                     : %6d
RODT nctl                                     : %6d
DDR PMOS control                              : %6d
DDR NMOS control                              : %6d
ddr_read_level
Parameter found in environment. ddr_read_level = %d
Rank(%d) Status / Deskew Bytes 8:0      %#6x : %2d %2d %2d %2d %2d %2d %2d %2d %2d
Rank(%d) Read Level Debug Test Results 8:0     : %04x %04x %04x %04x %04x %04x %04x %04x %04x
lmc_nxm                                       :     %02x
disable_l2_index_aliasing
L2 index aliasing disabled.
limit_l2_ways
Limiting L2 to %d ways
Invalid limit_l2_ways value: %d, must be between 1 and %d
limit_dram_mbytes
Limiting DRAM size to %d MBytes based on limit_dram_mbytes env. variable
ERROR: cvmx_cmd_queue_shutdown: Unable to get queue information.
ERROR: cvmx_cmd_queue_shutdown: Queue still has data in it.
ERROR: cvmx_cmd_queue_initialize: Unable to get named block %s.
ERROR: cvmx_cmd_queue_initialize: Queue already initalized with different max_depth (%d).
ERROR: cvmx_cmd_queue_initialize: Queue already initalized with different FPA pool (%u).
ERROR: cvmx_cmd_queue_initialize: Queue already initalized with different FPA pool size (%u).
ERROR: cvmx_cmd_queue_initialize: FPA is not enabled.
ERROR: cvmx_cmd_queue_initialize: Unable to allocate initial buffer.
ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p
List of currently allocated named bootmem blocks:
Name: %s, address: 0x%08qx, size: 0x%08qx, index: %d
No named bootmem blocks exist.
Printing bootmem block list, descriptor: %p,  head is 0x%llx
Descriptor version: %d.%d
Warning: Bootmem descriptor version is newer than expected
mem list is empty!
Block address: 0x%08qx, size: 0x%08qx, next: 0x%08qx
Internal bootmem_alloc() error: ent: 0x%llx, next: 0x%llx
ERROR: no memory for cvmx_bootmem descriptor provided
ERROR: requested memory size too large, truncating to maximum size
FATAL ERROR: unable to allocate memory for bootmem descriptor!
Warning: Enabling IPD when IPD already enabled.
Enabling packet I/O on interface %d
Interface %d has %d ports (%s)
Illegal clock frequency (%d). CVMX_ASXX_TX_HI_WATERX not set
WARNING: FIX_IPD_PTR_ALIGNMENT buffer allocation failure.
WARNING: FIX_IPD_PTR_ALIGNMENT get_work() timeout occured.
WARNING: FIX_IPD_PTR_ALIGNMENT failed.
ERROR: RGMII initialize called in SPI interface
ERROR: Unsupported Octeon model in %s
SGMII%d: Timeout waiting for port %d to finish reset
SGMII%d: Timeout waiting for port %d to be idle
Cavium Networks Octeon SDK version 1.9.0, build 312
RGMII
DISABLED
GMII
PCIE
XAUI
SGMII
PICMG
LOOP
UNKNOWN
cvmx_helper_get_interface_index_num: Illegal IPD port number
cvmx_helper_get_interface_num: Illegal IPD port number
Packet Length:   %u
    Input Port:  %u
    QoS:         %u
    Buffers:     %u
    Buffer Start:%llx
    Buffer I   : %u
    Buffer Back: %u
    Buffer Pool: %u
    Buffer Data: %llx
    Buffer Size: %u
%02x
__cvmx_helper_setup_gmx: Illegal num_ports
SPI4000: write failed with status=0x%x
SPI4000: read failed with %d
SPI%d: Rx is now up
SPI%d: Tx is now up
SPI%d: Rx is synchronized, start sending calendar data
SPI%d: Waiting to sync on STX[%d] STAT
SPI%d: Timeout
SPI%d: Waiting for training
SPI%d: Waiting to see TsClk...
SPI%d: Waiting to see RsClk...
ERROR SPI%d: BIST failed on receive datapath FIFO
ERROR SPI%d: BIST failed on RX calendar table
ERROR SPI%d: BIST failed on TX calendar table
SPI%d: Restart %s
TX Halfplex
Rx Halfplex
Duplex
cvmx_helper_board_get_mii_address: Unknown board type %d
ERROR:
ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.
ERROR: The board type is mis-configured, and software malfunctions are likely.
ERROR: All boards require a unique board type to identify them.
%d.%d
%d%c
%s%c
CN%s%s-%s pass %s
Unsupported OCTEON Model in %s
ERROR: cvmx_get_l2c_tag association out of range
ERROR: cvmx_get_l2c_tag index out of range (arg: %d, max: %d)
Warning: RTC has invalid %s field
second
minute
hour
day of week
month
year
Error: RTC was passed wrong calendar values, write failed
Warning: RTC calendar is not configured properly
Warning: Enabling PKO when PKO already enabled.
ERROR: cvmx_pko_config_port: Invalid port %llu
ERROR: cvmx_pko_config_port: Invalid queue range %llu
ERROR: cvmx_pko_config_port: Static priority queues aren't contiguous or don't start at base queue. q: %d, eq: %d
ERROR: cvmx_pko_config_port: Static priority queues don't start at base queue. sq: %d
ERROR: cvmx_pko_config_port: Invalid priority %llu
ERROR: cvmx_pko_config_port: Unable to allocate output buffer.
ERROR: cvmx_pko_config_port: Port already setup.
ERROR: cvmx_pko_config_port: Command queue initialization failed.
FAT32   
FAT12   
FAT16   
Invalid FAT entry
            %s%c
 %8ld   %s%c
%d file(s), %d dir(s)
Error reading cluster
reading %s
No current device
Interface:  
SATA
SCSI
ATAPI
Unknown
  Device %d: 
No valid FAT fs found
Partition %d: Filesystem: %s "%s"
** Can't read from device %d **
** No FAT signature found on device %d **
** Partition %d not valid on device %d **
Failed to mount ext2 filesystem...
** ext2fs read block (indir 1) malloc failed. **
** ext2fs read block (indir 1) failed. **
** ext2fs read block (indir 2 1) malloc failed. **
** ext2fs read block (indir 2 1) failed. **
** ext2fs read block (indir 2 2) malloc failed. **
** ext2fs read block (indir 2 2) failed. **
** ext2fs doesn't support tripple indirect blocks. **
<DIR> 
<SYM> 
      
< ? > 
%10d %s
** Can not find directory. **
 ** ext2fs_devread() read outside partition sector %d
** Invalid Block Device Descriptor (NULL)
 ** ext2fs_devread() read error **
 ** ext2fs_devread() read error - block
 ** ext2fs_devread() read error - last part
%x:%x:%x:%x:%x:%x
none
%d.%d.%d.%d
## Warning: gatewayip needed but not set
bad length %d < %d
invalid RARP header
len bad %d < %d
checksum bad
 ICMP Host Redirect to 
netretry
once
ARP Retry count exceeded; starting again
vlan
nvlan
*** ERROR: ping address not given
*** ERROR: `serverip' not set
*** ERROR: `ipaddr' not set
*** ERROR: No ethernet found.
*** ERROR: `ethaddr' not set
*** ERROR: `eth%daddr' not set
Using %s device
Abort
RST2DEF %d
Bytes transferred = %ld (%lx hex), %d Kbytes/sec
%02lX%02lX%02lX%02lX.img
*** Warning: no boot file name; using '%s'
TFTP from server 
; our IP address is 
; sending through gateway 
Filename '%s'.
 Size is 0x%x Bytes = 
Load address: 0x%lx
Loading: *
octet
timeout
File too large
File has bad magic
Access violation
Starting again ...
WARNING: Got duplicate packet (block %d)
TFTP error: First block is not block 1 (%ld)
TFTP error: '%s' (%d)
Timeout
** TFTP server (dev: %s, IP:%s) **
TFTP server got read request, file: "%s"
TFTP error: Access violation
TFTP server got write request, file: "%s"
TFTP error: First block should be 1 (got %ld)
TFTP error: file is too large 
*** WARNING: %s is too long (%d - max: %d) - truncated
BOOTP broadcast %d
Host Name
Root Path
Boot command
NetOurBootCommand
*** Unhandled DHCP Option in OFFER/ACK: %d
DHCP client bound to address 
autoload
DHCP: INVALID STATE
Retry count exceeded; starting again
RARP broadcast %d
ethact
No ethernet found.
Networking disabled by 'disable_networking' env variable.
ethprime
 [PRIME]
eth%daddr
Partition Map for 
 device %d  --   Partition Type: %s
## Unknown partition table
not available
(%d:%d) 
Model: %s Firm: %s Ser#: %s
Vendor: %s Prod.: %s Rev: %s
            Type: 
Removable 
Hard Disk
CD ROM
Optical Device
Tape
# %02X #
            Supports 48-bit addressing
            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)
            Capacity: not available
            MWDMA mode: %d
            UDMA mode: %d
** Can't read partition table on %d:%d **
bad MBR sector signature 0x%02x%02x
    1		         0	%10ld	%2x
 Extd
%5d		%10d	%10d	%2x%s
Partition     Start Sector     Num Sectors     Type
hd%c%d
sd%c%d
usbd%c%d
docd%c%d
xx%c%d
%s FLASH (%d x %d)
  Size: %ld kB in %d Sectors
  Size: %ld MB in %d Sectors
Intel Prog Regions
Intel Standard
Intel Extended
AMD Standard
AMD Extended
Unknown (%d)
 command set, Manufacturer ID: 0x%02X, Device ID: 0x%02X
%04X
  Erase timeout: %ld ms, write timeout: %ld ms
  Buffer write timeout: %ld ms, buffer size: %d bytes
  Sector Start Addresses:
  %08lX   %s 
Flash %s timeout at address %lx data %lx
Flash %s error at address %lx
Command Sequence Error.
Block Erase Error.
Locking Error
Block locked.
Vpp Low Error.
Can't erase unknown flash type - aborted
- no sectors to erase
- Warning: %d protected sectors will not be erased!
CFI conformant
CFI: Unknown command set 0x%x
%d erase regions found, only %d used
ERROR: too many flash sectors
## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB
%u MiB
No oob scheme defined for oobsize %d
No ECC functions supplied, Hardware ECC not possible
U-Boot BUG at %s:%d!
nand_base.c
%d byte HW ECC not possible on %d byte page size, fallback to SW ECC
NAND_ECC_NONE selected by board driver. This is not recommended !!
Invalid NAND_ECC_MODE %d
Invalid ecc parameters
nand_resume() called for a chip which is not in suspended state
%s: second ID read did not match %02x,%02x against %02x,%02x
NAND device: Manufacturer ID: 0x%02x, Chip ID: 0x%02x (%s %s)
NAND bus width %d instead %d bit
No NAND device found!!!
%d NAND chips detected
Timeout!
nand_write: Attempt to write not page aligned data
nand_do_write_ops: Device is write protected
NAND 16MiB 1,8V 8-bit
NAND 16MiB 3,3V 8-bit
NAND 16MiB 1,8V 16-bit
NAND 16MiB 3,3V 16-bit
NAND 32MiB 1,8V 8-bit
NAND 32MiB 3,3V 8-bit
NAND 32MiB 1,8V 16-bit
NAND 32MiB 3,3V 16-bit
NAND 64MiB 1,8V 8-bit
NAND 64MiB 3,3V 8-bit
NAND 64MiB 1,8V 16-bit
NAND 64MiB 3,3V 16-bit
NAND 128MiB 1,8V 8-bit
NAND 128MiB 3,3V 8-bit
NAND 128MiB 1,8V 16-bit
NAND 128MiB 3,3V 16-bit
NAND 256MiB 3,3V 8-bit
NAND 256MiB 1,8V 8-bit
NAND 256MiB 1,8V 16-bit
NAND 256MiB 3,3V 16-bit
NAND 512MiB 1,8V 8-bit
NAND 512MiB 3,3V 8-bit
NAND 512MiB 1,8V 16-bit
NAND 512MiB 3,3V 16-bit
NAND 1GiB 1,8V 8-bit
NAND 1GiB 3,3V 8-bit
NAND 1GiB 1,8V 16-bit
NAND 1GiB 3,3V 16-bit
NAND 2GiB 1,8V 8-bit
NAND 2GiB 3,3V 8-bit
NAND 2GiB 1,8V 16-bit
NAND 2GiB 3,3V 16-bit
AND 128MiB 3,3V 8-bit
Toshiba
Samsung
Fujitsu
National
Renesas
ST Micro
Hynix
Micron
create_bbt(): chipnr (%d) > available chips (%d)
Bad block table not found for chip %d
Bad block table found at page %d, version 0x%02X
nand_bbt: Error reading bad block table
nand_bbt: ECC error while reading bad block table
nand_read_bbt: Reserved block at 0x%08x
nand_read_bbt: Bad block at 0x%08x
No space left to write bad block table
nand_bbt: Error reading block for writing the bad block table
nand_bbt: ECC error while reading block for writing bad block table
Bad block table written to 0x%08x, version 0x%02X
nand_bbt: Error while writing bad block table %d
nand_update_bbt: Out of memory
nand_scan_bbt: Out of memory
nand_bbt: Can't scan flash and build the RAM-based BBT
nand_bbt: Out of memory
Bad block table at page %d, version 0x%02X
Attempt to read outside the flash area
NAND read from offset %x failed %d
Skipping bad block 0x%08x
Attempt to write non page aligned data
Attempt to write outside the flash area
NAND write to offset %x failed %d
Skip bad block 0x%08x
Warning: Erase size 0x%08lx smaller than one erase block 0x%08x
         Erasing 0x%08x instead
Skipping bad block at  0x%08x                                            
%s: MTD get bad block failed: %d
%s: MTD Erase failure: %d
%s: MTD writeoob failure: %d
Erasing at 0x%x -- %3d%% complete.
 Cleanmarker written at 0x%x.
VNAND Internal bad blocks table not initialized yet
NAND ERROR: %s(): failed to read block %ld
NAND ERROR: %s(): block %ld is not erased
NAND ERROR: %s(): failed to read block %ld oob data
NAND DEBUG: %s(): copy block %ld to block %ld
NAND ERROR: %s(): read src block %ld failed
NAND ERROR: %s(): write dest block %ld failed
NAND ERROR: %s(): read src oob data of block %ld failed
NAND ERROR: %s(): read src oob data of block %ld failed - read %ld bytes instead of %d
NAND ERROR: %s(): write dest oob data of block %ld failed
NAND ERROR: %s(): write src oob data of block %ld failed - read %ld bytes instead of %d
NAND : %s(): mark block %ld as 0x%02x
NAND ERROR: %s(): failed to write block %ld oob
NAND DEBUG: %s(): eraes block %ld
NAND ERROR: %s(): erase block %ld failed
VNAND: %s(): initialize Virtual NAND driver %s
v1.2 25/10/09
VNAND: %s(): vnand driver already initialized
VNAND ERROR: %s(): failed to kmalloc() temp_block_buff(%d bytes)
VNAND ERROR: %s(): failed to kmalloc() translate block table(%ld bytes).
VNAND ERROR: %s(): failed to get block %ld status
VNAND: %s(): NAND bad block at %ld (oob bad block type = 0x%x)
VNAND ERROR: %s(): found too many NAND bad blocks (%d) !!!
VNAND ERROR: %s(): (BUG)failed to find alternative block to block %ld
VNAND: %s(): bad block %ld remap to block %ld
did not
VNAND: %s(): NAND check %s find bad blocks
VNAND ERROR: %s(): failed to build translate block table
%d.%02x 
VNAND ERROR: %s(): attempt read beyond end of device
VNAND ERROR: %s(): failed to convert block %ld
VNAND ERROR: %s(): partial read failed from 0x%08x, size: %d, ret: %d, read len: %lu
VNAND ERROR: %s(): failed to translate block %ld
VNAND: %s(): searching alternative block to block %ld
VNAND ERROR: %s(): too many NAND bad blocks (%d)
VNAND: %s(): bad alternative block %ld, breking old mapping
VNAND: %s(): remap block %ld to new alternative block %ld
VNAND ERROR: %s(): failed to erase next phy block %ld, continue anyway
VNAND ERROR: %s(): failed to copy old block %ld to new block %ld, continue anyway
VNAND: %s(): remap bad block %ld to alternative block %ld
VNAND ERROR: %s(): failed to erase new block %ld, continue anyway
VNAND ERROR: %s(): failed to mark old block %ld, continue anyway
VNAND ERROR: %s(): can't erase unaligned address 0x%08x
VNAND ERROR: %s(): length 0x%x is not block aligned
VNAND ERROR: %s(): erase past end of device (0x%x, 0x%x, 0x%x)
VNAND ERROR: %s(): partial erase block %ld failed
VNAND: %s(): retry to erase block %ld
VNAND: %s(): try to remap block %ld
VNAND ERROR: %s(): failed to remap block %ld
VNAND ERROR: %s(): attempt to write past end of page
VNAND ERROR: %s(): Asked to write %u bytes, %ld bytes were written
VNAND ERROR: %s(): not IO error at block %ld
VNAND ERROR: %s(): IO error at block %ld
VNAND: %s(): retry to write block %ld
VNAND ERROR: %s(): failed to read block %ld
%2ld
.%ld
 %cB%s
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789abcdefghijklmnopqrstuvwxyz
<NULL>
unknown compression method
invalid window size
invalid reserved bit
incorrect header check
invalid block type
invalid stored block lengths
too many length or distance symbols
oversubscribed dynamic bit lengths tree
incomplete dynamic bit lengths tree
invalid bit length repeat
oversubscribed literal/length tree
incomplete literal/length tree
invalid distance code
invalid literal/length code
incorrect data check
0.95P
stream end
file error
stream error
data error
insufficient memory
buffer error
native
PRIMARY
SECONDARY
ERROR: unknown firmware type %d.
Bin2Go
SofaWare Firmware
Arrow Boot Loader
Arrow Debug Boot Loader
NA-C38 Boot Loader
GB Boot Loader
CM Boot Loader
GZIP
None
BZIP
<<***** SofaWare Image Details *****>>
<<***** SofaWare %s Image Details *****>>
Vendor Mask             : 0x%X
Version Num             : "%s"
File Type               : "%s" (%d) 
Total File Size         : 0x%08x
Image Size              : 0x%08x
Run Image Size          : 0x%08x
Unzipped Run Image Size : 0x%08x
Zip Type                : "%s"
Run Address             : 0x%08x
dsl_modem_reset
sw_sec_firm
firm0
sw_pri_firm
firm1
Run boot loader from address 0x%08x
Error: Image is corrupted. Calculated CRC 0x%x, while image's header defines 0x%x
DSL image CRC: 0x%x is valid
nand_write: WARNING: Increasing size to match block size
ERROR: Failed to erase %ld bytes from offset %ld
ERROR: failed to write %ld bytes to offset %ld
Reset configuration file ...
ERROR: failed to reset configuration file
ERROR: Config file too large
Installing configuration file ...
ERROR: failed to write configuration file
# END Configuration script
ERROR: failed to read %ld bytes from offset %ld
Get secondary dsl firm Annex
ERROR: Failed to Read secondary dsl-frimware's header.
ERROR: No dsl backup firmware found. Operation aborted.
ERROR: Secondary-dsl-firmware's Annex is corrupted (%x)
Error: dsl firmware is too small - %d Bytes
Error: firmware magic 0x%x is wrong
Error: Mismatch with img sizes. Image size=%d, Header part=%d, Data part=%d.
Data part + Header part = %d, differ from Image size (%d).
dsl-firmware header's annex: 0x%x, does not matches to the file name's annex: 0x%x.
New primary-dsl-firmware header's annex (%x) differ from
the installed secondary-dsl-firmware annex (%x)
Read primary dsl header from flash
ERROR: Can not read dsl-header primary partition. Operation failed.
dsl main firmware is OK
No dsl main firmware
nand_delete: WARNING: Increasing size to match block size
ERROR: Failed to delete SofaWare cloud storage file.
ERROR: Failed to delete SofaWare parameters validation file.
File length=%d. Going to read %d pages from SPI.
Error: Too much pages to read - %d. Max pages is %d.
Error: spi_read failed
Dsl Header:
xsum: 0x%x
magic: 0x%x
size: 0x%x (%d)
annex: 0x%x [blob's annex: 0x%x]
version: %s
Validate input buffer crc
Writing primary dsl header to flash... 
ERROR: Write primary dsl header failed 
ERROR: Read primary dsl header failed 
ERROR: Input buffer differ from the buffer wrote to flash
Erasing SPI
Writing from flash 0x%x, size %d to SPI
Error: Write operation failed
Read firmware from modem and calculate CRC
Error: Read operation failed
Error: spi crc (0x%x) differ from input buffer crc (0x%x) - EEProm Write/Read operation failed
dsl main firmware wrote successfully to modem [spi crc 0x%x]
Writing backup DSL firmware to flash...
ERROR: Backup dsl-firmware is too big (%d > %d)
ERROR: Write secondary dsl-firmware failed
ERROR: Read secondary dsl-frimware failed
Validate secondary dsl image on flash..
Read dsl backup firmware
ERROR: Failed to Read secondary dsl-frimware.
No dsl backup firmware found. Operation aborted.
Check dsl backup firmware
Wrong CRC in dsl backup firmware. Operation aborted.
SofaWare debug level: %d
ERROR: configuration file is too big (%d bytes, max %d).
# Configuration script
ERROR: configuration file is too small (%d bytes).
ERROR: invalid configuration file. 
.bls
# Arrow Boot Loader script
ERROR: Boot loader script is too small (%d bytes). 
ERROR: invalid boot loader script. 
.cfg
.firm
ERROR: Could not read CFG file header.
Reading %s firmware header from %ld...
ERROR: failed to read %s firmware header.
ERROR: Invalid header
Image  size: %ld bytes
Reading %s firmware...
ERROR: failed to read %s firmware.
Verify %s firmware ...
ERROR: failed to verify %s firmware.
%s firmware OK
ERROR: Secondary image header bad. Scanning for PRIMARY image
Found PRIMARY image at offset %ld
ERROR: Invalid firmware type
ERROR: Failed to scan detect PRIMARY image
Writing SECONDARY firmware ... 
ERROR: Write SECONDARY firmware failed 
SECONDARY firmware is bad, storing PRIMARY firmware as SECONDARY firmware
Could not install SECONDARY firmware
Could not install PRIMARY firmware - bad SECONDARY firmware could not be fixed
Writing PRIMARY firmware ... 
ERROR: Write PRIMARY firmware failed 
ERROR: failed to write verify file "%s" on CF %d.
sw_test_mode
sw_user_src
sw_kernel_src
sw_def_lan_ip
sw_def_wan_ip
sw_debug_host_ip
sw_debug_host_port
blob_license
blob_activation_key
blob_vendor_mask
blob_sfp_ports
blob_usb_ports
blob_switch_ports
blob_part_number
blob_serial_number
blob_wlan_region
WORLD
ETSIA
ETSIB
ETSIC
FCCA
MKKA
blob_ex_param1
blob_ex_param2
blob_ex_param3
blob_ex_param4
blob_ex_param5
blob_ex_param6
blob_ex_param7
blob_ex_param8
** SofaWare boot information (core %d) ** 
* license (blob):           "%s"
* activation key (blob):    "%s"
* vendor mask (blob):       0x%X
* pn (blob):                "%s"
* sn (blob):                "%s"
* SFP ports (blob):         0x%X
* USB ports (blob):         0x%X
* Switch ports (blob):      0x%X
* WLAN Region (blob):         "%s"
* DSL Modem (blob):                "%s"
* ANNEX (blob):                "%s"
* extra params 1 (blob):    "%s"
* extra params 2 (blob):    "%s"
* extra params 3 (blob):    "%s"
* extra params 4 (blob):    "%s"
* extra params 5 (blob):    "%s"
* extra params 6 (blob):    "%s"
* extra params 7 (blob):    "%s"
* extra params 8 (blob):    "%s"
* default ip:               %d.%d.%d.%d
* sub model:                0x%X
* image version:            "%s"
* firmware file name:       "%s"
* kernel image size:        %u
* firmware image offset:           %u
* romdisk offset:           %u
* image crc:                0x%X
* loader ver:               %u
* test mode:                %u
* debug:                    %u
* safe@ user source:        %u
* safe@ kernel source:      %u
* default lan ip:           "%s"
* default wan ip:           "%s"
* debug host ip:            "%s"
* debug host port:          "%d"
**************************************** 
ERROR: BLOB does not exist.
Unzip image to address 0x%08x ...
ERROR: Failed to unzip image.
ERROR: unsupported image zip type (%d).
Flatting image to address 0x%08x
sw_cores_num
0x%08x
numcores=%d
Running image from address 0x%08x (cores %d)...
mtdparts=phys_mapped_flash:64k@0x7d0000(cfgfile)
sw_linux_cmdline
ERROR: Invalid flash address (0x%08x:%d).
Erasing flash at 0x%08x-0x%08x ...
ERROR: Failed to erase flash (0x%08x:%d).
Writing flash at 0x%08x-0x%08x ...
ERROR: Failed to write flash (0x%08x:%d).
Update BLOB at address 0x%08x
WARNING: Could not get uboot_flash_addr from environment. Using default (0x%x).
Bootloader load address: 0x%x
WARNING: Could not get uboot_flash_size from environment. Using default (0x%x).
Bootloader size: 0x%x
ERROR: Bootcode size (%ld) exceeded maximum size (%ld).
Updating bootcode at address 0x%08x
Runnig script ...
ERROR: command at line %d is too long, skip it.
setenv 
Command "%s" unauthorized
ERROR: LED %d does not exist
File Name           : "%s"
File Size           : 0x%08x
ERROR: SWFS image is too short
#SW#
ERROR: SWFS does not have magic number
SWFS Version        : %d
Number Of Files     : %d
<<***** SWFS Files Details *****>>
ERROR: parameter at offset %d and size %d is out of the blob.
ERROR: Can't update BLOB, no MAC address.
ERROR: Base MAC address must match the board MAC while updating BLOB.
ERROR: WLAN region must be set to one of the following values:
       WORLD
       ETSIA
       ETSIB
       ETSIC
       FCCA
       MKKA
ERROR: DSL Modem ANNEX type must be set to one of the following values:
       A
       B
No blob was found :-( 
<<***** BLOB Details *****>>
!!! TEMPORARY BLOB !!!
!!! TEMPORARY BLOB !!!
!!! TEMPORARY BLOB !!!
LAN MAC                : %s 
DMZ MAC                : %s 
WAN MAC                : %s 
License Key            : %s 
Activation Key         : %s 
Serial Num             : %s 
Part Num               : %s 
Vendor Mask            : %s 
Number of SFP Ports    : %s 
Number of USB Ports    : %s 
Number of Switch Ports : %s 
WLAN Region            : %s 
DSL Modem              : %s 
ANNEX                  : %s 
Extra Param 1  : %s 
Extra Param 2  : %s 
Extra Param 3  : %s 
Extra Param 4  : %s 
Extra Param 5  : %s 
Extra Param 6  : %s 
Extra Param 7  : %s 
Extra Param 8  : %s 
ERROR: BLOB parameter "%s" value is too long (got %d, max %d) 
ERROR: CPU have only %d cores 
internal
%02X:%02X:%02X:%02X:%02X:%02X
Old firmware not supported by this bootloader
ERROR: bad dsl image header.
ERROR: bad image xsum 0x%x (expected 0x%x).
ERROR: bad image header.
ERROR: faild to mount IDE device %d
ERROR: faild to unlink file "%s" on IDE device %d
ERROR: faild to open source file "%s" on IDE device %d
ERROR: faild to open destination file "%s" on IDE device %d
ERROR: faild to open file "%s" on IDE device %d
ERROR: faild to write file "%s" on IDE device, disk %d is full
ERROR: faild to write file "%s" on IDE device %d
ERROR: failed to read file "%s" on IDE device %d
%s/%s
ERROR: "%s" - no such directory
FAT32
ERROR: ff_disk_write invalid drive (%d)
ERROR: ff_disk_write failed, drive %d not initialized
ERROR: ff_disk_write failed to write to drive %d
ERROR: ff_disk_read invalid drive (%d)
ERROR: ff_disk_read failed, drive %d not initialized
ERROR: ff_disk_read failed to read from drive %d
0123456789abcdef
cvmx_pow_work_request_sync
cvmx_pow_work_request_sync_nocheck
U-Boot 1.1.1  SDK 1.9 (Development build) (Build time: Feb  2 2011 - 12:54:14)
(2<FPZ
!2BK
cvmx_pow_work_request_sync
cvmx_pow_work_request_sync_nocheck
__cvmx_helper_rgmii_probe
cvmx_l2c_get_num_assoc
cvmx_l2c_get_set_bits
Unand
nand_get_flash_type
e03f<ij??ji<f30ef30e?ji<<ij?e03f
i<?j0ef33fe0j?<i
j?<i3fe00ef3i<?jj?<i3fe00ef3i<?j
i<?j0ef33fe0j?<i
f30e?ji<<ij?e03fe03f<ij??ji<f30e
nand_copy_block
nand_erase_block
nand_verify_erase
get_block_status
set_block_status
vnand_scan
build_translate_table
vnand_write_oob_cb
virt2phy_block
vnand_read_oob_cb
vnand_write_ecc
remap_block
vnand_read_ecc
vnand_erase_cb
gqr<
$/o|
f-=v
mj>zjZ
l6qnk
IiGM>nw
                          Yyy                 yyY    
                           YYYYYYYyyyyyyyYYYYYYY     
                            YYYYY#########YYYYY      
                             YYY#    ???  #YYY       
                              YY#   ( O)  #YY        
                               Y#    ~~   #Y         
                               YY#########YY         
                          @@@  YYYYYYYYYYYYY  @@@    
                          @@@@ YYYYYYYYYYYYY @@@@    
                          @@@@ YYYYYYYYYYYYY @@@@    
                           @@@@@@@@@@@@@@@@@@@@@     
                            @@@@@@@@@@@@@@@@@@@      
                            VVV@@@@@@@@@@@@@VVV      
                            VV               VV      
                            V                 V      
                              SofaWare Embedded!     
                                    Sbox4  
Boot Code Version: 15 (Build time: Feb  2 2011 - 12:53:34)
|/-\
PPP`<(<-  '
bootdelay=0
baudrate=115200
download_baudrate=115200
ipaddr=192.168.10.1
bootloader_flash_update=protect off $(uboot_flash_addr) +$(uboot_flash_size);erase $(uboot_flash_addr) +$(uboot_flash_size);cp.b $(fileaddr) $(uboot_flash_addr) $(uboot_flash_size);run nuke_env
burn_app=erase $(flash_unused_addr) +$(filesize);cp.b $(fileaddr) $(flash_unused_addr) $(filesize)
bf=bootoct $(flash_unused_addr) forceboot numcores=$(numcores)
nuke_env=protect off $(env_addr) +$(env_size); erase $(env_addr) +$(env_size)
linux_cf=fatload ide 0 $(loadaddr) vmlinux.64;bootoctlinux $(loadaddr)
ls=fatls ide 0
autoload=n
autotest=1
ipaddr=192.168.10.1
serverip=192.168.10.10
ethact=octeth1
        
Bbt0
1tbB
(((((
AAAAAA
BBBBBB
blob_mac
blob_license
 blob_activation_key
 blob_vendor_mask
blob_part_number
blob_serial_number
blob_sfp_ports
blob_usb_ports
blob_switch_ports
blob_wlan_region
blob_adsl_annex
blob_ex_param1
 blob_ex_param2
 blob_ex_param3
 blob_ex_param4
 blob_ex_param5
 blob_ex_param6
 blob_ex_param7
 blob_ex_param8
 sw_user_src
native
sw_kernel_src
native
sw_tftp_any_file
sw_test_mode
sw_tftpsrvmode
sw_pri_firm
firm1
sw_sec_firm
firm0
sw_linux_cmdline
sw_cores_num
sw_serial_console
internal
sw_def_lan_ip
sw_def_wan_ip
sw_debug_host_ip
sw_debug_host_port
400-08-DA-82-B0-11
0207e3-0dafb6-58dc87
308709-VZ7Y-F9UA-97GG-C0VZVS
308709
0x00002000
WORLD
bootdelay=0
baudrate=115200
download_baudrate=115200
ipaddr=192.168.10.1
bootloader_flash_update=protect off $(uboot_flash_addr) +$(uboot_flash_size);erase $(uboot_flash_addr) +$(uboot_flash_size);cp.b $(fileaddr) $(uboot_flash_addr) $(uboot_flash_size);run nuke_env
burn_app=erase $(flash_unused_addr) +$(filesize);cp.b $(fileaddr) $(flash_unused_addr) $(filesize)
bf=bootoct $(flash_unused_addr) forceboot numcores=$(numcores)
nuke_env=protect off $(env_addr) +$(env_size); erase $(env_addr) +$(env_size)
linux_cf=fatload ide 0 $(loadaddr) vmlinux.64;bootoctlinux $(loadaddr)
ls=fatls ide 0
autoload=n
autotest=1
ipaddr=192.168.10.1
serverip=192.168.10.10
ethact=octeth1
